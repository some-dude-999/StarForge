<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>28mm STL Scaler with Reference Man Overlay</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            color: #ffffff;
            padding-top: 90px;
            padding-bottom: 70px;
        }
        .sticky-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: #2a2a2a;
            border-bottom: 3px solid #4CAF50;
            padding: 6px 15px;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        .sticky-header button {
            padding: 6px 10px;
            font-size: 11px;
            font-weight: bold;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .sticky-header button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background-color: #555 !important;
        }
        .sticky-footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: #2a2a2a;
            border-top: 3px solid #4CAF50;
            padding: 10px 15px;
            z-index: 1000;
            box-shadow: 0 -4px 6px rgba(0,0,0,0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
        }
        .sticky-footer button {
            padding: 8px 16px;
            font-size: 13px;
            font-weight: bold;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .sticky-footer button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background-color: #555 !important;
        }
        .sticky-footer .pagination-info {
            font-size: 14px;
            font-weight: bold;
            color: #4CAF50;
            min-width: 200px;
            text-align: center;
        }
        .btn-process { background-color: #4CAF50; color: white; }
        .btn-process:hover:not(:disabled) { background-color: #45a049; }
        .btn-yellow { background-color: #FFC107; color: #000; font-weight: bold; }
        .btn-yellow:hover:not(:disabled) { background-color: #FFB300; }
        .btn-blue { background-color: #2196F3; color: white; }
        .btn-blue:hover:not(:disabled) { background-color: #1976D2; }
        .btn-pink { background-color: #E91E63; color: white; }
        .btn-pink:hover:not(:disabled) { background-color: #C2185B; }
        .btn-green { background-color: #4CAF50; color: white; }
        .btn-green:hover:not(:disabled) { background-color: #388E3C; }
        .btn-clear { background-color: #f44336; color: white; }
        .btn-clear:hover:not(:disabled) { background-color: #d32f2f; }
        .btn-nav { background-color: #607D8B; color: white; }
        .btn-nav:hover:not(:disabled) { background-color: #455A64; }
        .btn-export { background-color: #2196F3; color: white; }
        .btn-export:hover:not(:disabled) { background-color: #1976D2; }
        .btn-all { background-color: #9C27B0; color: white; }
        .btn-all:hover:not(:disabled) { background-color: #7B1FA2; }
        .divider {
            width: 2px;
            height: 30px;
            background-color: #555;
            align-self: center;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 15px;
        }
        h1 {
            text-align: center;
            color: #4CAF50;
            margin-bottom: 20px;
        }
        .drop-zone {
            border: 3px dashed #4CAF50;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            background-color: #2a2a2a;
            transition: all 0.3s ease;
            cursor: pointer;
            margin: 20px auto;
            max-width: 600px;
        }
        .drop-zone:hover {
            border-color: #66BB6A;
            background-color: #333;
        }
        .drop-zone.dragover {
            border-color: #81C784;
            background-color: #3a3a3a;
            transform: scale(1.02);
        }
        .file-list {
            background-color: #2a2a2a;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            display: none;
        }
        .file-list h3 {
            color: #4CAF50;
            margin-bottom: 10px;
        }
        .file-item {
            padding: 5px 10px;
            background-color: #333;
            margin: 5px 0;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .file-item button {
            background-color: #ff6b6b;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
        }
        .loading {
            text-align: center;
            color: #4CAF50;
            font-size: 18px;
            padding: 15px;
            display: none;
        }
        .loading-progress {
            width: 100%;
            max-width: 600px;
            height: 30px;
            background-color: #2a2a2a;
            border-radius: 15px;
            margin: 15px auto;
            overflow: hidden;
            border: 2px solid #4CAF50;
        }
        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #66BB6A);
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
        }
        .loading-message {
            color: #aaa;
            font-size: 14px;
            margin-top: 10px;
        }
        #stages-container {
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
        }
        .model-card {
            background-color: #2a2a2a;
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .model-title {
            color: #4CAF50;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
        }
        .card-controls {
            display: flex;
            gap: 8px;
            justify-content: center;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        .card-controls button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            transition: all 0.2s;
        }
        .card-controls button:hover {
            transform: scale(1.05);
        }
        .card-controls .btn-zoom {
            background: #2196F3;
            width: 36px;
            height: 36px;
            padding: 0;
            font-size: 18px;
        }
        .card-controls .btn-center {
            background: #9C27B0;
            padding: 8px 16px;
        }
        .card-controls .btn-download-all {
            background: #FF9800;
        }
        .viewport {
            width: 100%;
            aspect-ratio: 1 / 1;
            background: linear-gradient(to bottom, #3a3a3a, #2a2a2a);
            border-radius: 8px;
            position: relative;
            border: 2px solid #444;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
            cursor: default;
            user-select: none;
        }
        .alignment-status {
            position: absolute;
            left: 10px;
            bottom: 10px;
            background: rgba(0,0,0,0.8);
            color: #66ff66;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 11px;
            z-index: 10;
            pointer-events: none;
            text-align: center;
        }
        .alignment-status.not-flat {
            color: #ff6666;
        }
        .height-controls {
            display: flex;
            gap: 8px;
            justify-content: center;
            align-items: center;
            margin: 10px 0;
            padding: 8px 12px;
            background-color: #1a1a1a;
            border-radius: 8px;
            border: 1px solid #333;
        }
        .height-input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        .height-btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            width: 50px;
            height: 18px;
            cursor: pointer;
            font-size: 10px;
            line-height: 1;
            padding: 0;
            transition: background-color 0.2s;
        }
        .height-btn:hover {
            background-color: #45a049;
        }
        .height-input {
            width: 50px;
            padding: 6px 4px;
            border: 2px solid #4CAF50;
            background-color: #1a1a1a;
            color: #fff;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            border-radius: 0;
        }
        .height-input::-webkit-inner-spin-button,
        .height-input::-webkit-outer-spin-button {
            display: none;
        }
        .unit-label {
            color: #aaa;
            font-size: 14px;
            font-weight: bold;
        }
        .mm-display {
            color: #4CAF50;
            font-size: 12px;
            font-weight: bold;
            margin-left: 8px;
        }
        /* X-AXIS ROTATION CONTROLS - RED */
        .rotation-controls.x-axis {
            padding: 8px 12px;
            background-color: #3a1a1a;
            border-radius: 8px;
            margin-top: 5px;
            border: 2px solid #f44336;
        }
        .rotation-slider.x-axis {
            width: 100%;
            margin: 10px 0;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #3a1a1a;
            outline: none;
            border-radius: 3px;
            border: 1px solid #f44336;
        }
        .rotation-slider.x-axis::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #f44336;
            cursor: pointer;
            border-radius: 50%;
        }
        .rotation-slider.x-axis::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #f44336;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        .rotation-label.x-axis {
            display: block;
            font-size: 12px;
            color: #f44336;
            text-align: center;
            font-weight: bold;
        }
        /* Y-AXIS ROTATION CONTROLS - GREEN */
        .rotation-controls.y-axis {
            padding: 8px 12px;
            background-color: #1a3a1a;
            border-radius: 8px;
            margin-top: 5px;
            border: 2px solid #4CAF50;
        }
        .rotation-slider.y-axis {
            width: 100%;
            margin: 10px 0;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #1a3a1a;
            outline: none;
            border-radius: 3px;
            border: 1px solid #4CAF50;
        }
        .rotation-slider.y-axis::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #4CAF50;
            cursor: pointer;
            border-radius: 50%;
        }
        .rotation-slider.y-axis::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #4CAF50;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        .rotation-label.y-axis {
            display: block;
            font-size: 12px;
            color: #4CAF50;
            text-align: center;
            font-weight: bold;
        }
        /* Z-AXIS ROTATION CONTROLS - BLUE */
        .rotation-controls.z-axis {
            padding: 8px 12px;
            background-color: #1a1a3a;
            border-radius: 8px;
            margin-top: 5px;
            border: 2px solid #2196F3;
        }
        .rotation-slider.z-axis {
            width: 100%;
            margin: 10px 0;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #1a1a3a;
            outline: none;
            border-radius: 3px;
            border: 1px solid #2196F3;
        }
        .rotation-slider.z-axis::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #2196F3;
            cursor: pointer;
            border-radius: 50%;
        }
        .rotation-slider.z-axis::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #2196F3;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        .rotation-label.z-axis {
            display: block;
            font-size: 12px;
            color: #2196F3;
            text-align: center;
            font-weight: bold;
        }
        .flatness-status {
            margin: 10px 0;
            font-size: 14px;
            font-weight: bold;
            padding: 10px 12px;
            border-radius: 6px;
            text-align: center;
            line-height: 1.4;
        }
        .flatness-status.flat {
            color: #66ff66;
            background-color: rgba(76, 175, 80, 0.2);
            border: 2px solid rgba(76, 175, 80, 0.5);
        }
        .flatness-status.not-flat {
            color: #ff6666;
            background-color: rgba(255, 0, 0, 0.2);
            border: 2px solid rgba(255, 0, 0, 0.5);
        }
        .info {
            text-align: center;
            color: #888;
            margin-bottom: 15px;
            padding: 8px;
            background-color: #222;
            border-radius: 5px;
        }
        .error-message {
            color: #ff6b6b;
            text-align: center;
            padding: 10px;
            background-color: #3a2a2a;
            border-radius: 5px;
            margin: 10px 0;
            display: none;
        }
        .cut-mode-controls {
            padding: 8px 12px;
            background-color: #3a2a1a;
            border-radius: 8px;
            margin-top: 10px;
            border: 2px solid #FF9800;
        }
        .cut-mode-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            justify-content: center;
        }
        .cut-mode-checkbox input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        .cut-mode-checkbox label {
            color: #FF9800;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
        }
        .cut-height-controls {
            display: none;
            flex-direction: column;
            gap: 8px;
        }
        .cut-height-controls.active {
            display: flex;
        }
        .cut-height-adjuster {
            display: flex;
            gap: 8px;
            justify-content: center;
            align-items: center;
        }
        .cut-height-btn {
            background-color: #FF9800;
            color: white;
            border: none;
            width: 40px;
            height: 30px;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            padding: 0;
            transition: background-color 0.2s;
            border-radius: 4px;
            font-weight: bold;
        }
        .cut-height-btn:hover {
            background-color: #F57C00;
        }
        .cut-height-input {
            width: 80px;
            padding: 6px 8px;
            border: 2px solid #FF9800;
            background-color: #1a1a1a;
            color: #fff;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            border-radius: 4px;
        }
        .cut-height-label {
            color: #FF9800;
            font-size: 12px;
            text-align: center;
            font-weight: bold;
        }
        .cut-button {
            background-color: #f44336;
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            border-radius: 6px;
            margin-top: 10px;
            width: 100%;
            transition: background-color 0.2s;
        }
        .cut-button:hover {
            background-color: #d32f2f;
        }
        .cut-button:disabled {
            background-color: #666;
            cursor: not-allowed;
            opacity: 0.5;
        }
        .floating-parts-control {
            padding: 6px 10px;
            background-color: #2a1a3a;
            border-radius: 6px;
            margin-top: 10px;
            border: 2px solid #9C27B0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .floating-parts-control input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        .floating-parts-control label {
            color: #9C27B0;
            font-weight: bold;
            font-size: 13px;
            cursor: pointer;
            margin: 0;
        }
        .model-height-label {
            position: absolute;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: #ff4444;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: bold;
            z-index: 6;
            pointer-events: none;
            text-align: center;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div class="sticky-header">
        <button class="btn-yellow" id="processNoScale" disabled>‚öôÔ∏è Process with No Scaling</button>
        <button class="btn-blue" id="process32mm" disabled>‚öîÔ∏è Scale to 6'2" for 28mm</button>
        <button class="btn-blue" id="process9ft" disabled>‚öîÔ∏è Scale to 9' for 28mm</button>
        <button class="btn-blue" id="process12ft" disabled>‚öîÔ∏è Scale to 12' for 28mm</button>
        <button class="btn-pink" id="process100mm" disabled>ü¶Ñ Scale to 100mm Cute</button>
        <button class="btn-green" id="process300mm" disabled>ü™¥ Scale to 290mm Planter</button>
        <span id="modelCountDisplay" style="font-size: 12px; font-weight: bold; color: #4CAF50; align-self: center;">0 models loaded</span>
        <div class="divider"></div>
        <button class="btn-clear" id="clearAll" disabled>üóëÔ∏è Clear</button>
        <button class="btn-all" id="exportEverything" disabled>üíæ Download All</button>
        <div class="divider"></div>
        <label style="display: flex; align-items: center; gap: 4px; font-size: 11px; cursor: pointer;">
            <input type="checkbox" id="globalRemoveFloating" checked style="width: 16px; height: 16px; cursor: pointer;">
            <span style="color: #4CAF50; font-weight: bold;">üßπ Remove Floating Parts</span>
        </label>
        <label style="display: flex; align-items: center; gap: 4px; font-size: 11px; cursor: pointer;">
            <input type="checkbox" id="debugBoundingBox" style="width: 16px; height: 16px; cursor: pointer;">
            <span style="color: #FFD700; font-weight: bold;">üì¶ Debug Bounding Box</span>
        </label>
    </div>
    <div class="sticky-footer">
        <button class="btn-nav" id="prevPage" disabled>‚óÄ Previous Page</button>
        <div class="pagination-info">
            <div id="pageDisplay" style="margin-bottom: 4px;">Page 1</div>
            <div id="footerModelCount" style="font-size: 12px; color: #aaa;">0 models loaded</div>
        </div>
        <button class="btn-nav" id="nextPage" disabled>Next Page ‚ñ∂</button>
    </div>
    <div class="container">
        <div class="drop-zone" id="dropZone">
            <h2>Upload Monsters/Creatures</h2>
            <p>Drop STL files here or click to browse</p>
        </div>
        <div class="error-message" id="errorMessage"></div>
        <div class="file-list" id="fileList">
            <h3>Loaded Files</h3>
            <div id="fileListContent"></div>
        </div>
        <div class="loading" id="loading">
            <div>Processing models...</div>
            <div class="loading-progress">
                <div class="loading-progress-bar" id="loadingProgressBar">0%</div>
            </div>
            <div class="loading-message" id="loadingMessage">Initializing...</div>
        </div>
        <div id="stages-container"></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/earcut@2.2.4/dist/earcut.min.js"></script>
    <script>
        if (typeof THREE === 'undefined') {
            document.getElementById('errorMessage').textContent = 'Failed to load 3D library. Please refresh the page.';
            document.getElementById('errorMessage').style.display = 'block';
        }
        window.addEventListener('load', () => {
            setTimeout(() => {
                if (typeof earcut !== 'undefined') {
                    console.log('‚úÖ Earcut triangulation library loaded');
                } else {
                    console.warn('‚ö†Ô∏è Earcut library not loaded - complex shape cutting may fail');
                }
            }, 500);
        });

        /*
         * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
         * StarForge STL Processing Tool - Internal Quality Control & Production Pipeline
         * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
         *
         * PURPOSE:
         * This web-based tool streamlines the STL model preparation workflow for 3D printing.
         * It provides quick scaling, flattening, bottom-cutting, and automated quality control
         * checks to ensure models are print-ready.
         *
         * KEY FEATURES:
         *
         * 1. SCALING & SIZE ADJUSTMENT
         *    - Multiple preset scales: 28mm tabletop gaming (6'2", 9', 12'), 100mm cute figures, 290mm planters
         *    - Real-time height adjustment in feet/inches or direct measurements
         *    - Visual scale reference with 3D human figure overlay
         *
         * 2. BOTTOM CUTTING & FLATTENING
         *    - Interactive cut mode with adjustable cut height
         *    - Automatic bottom surface generation using earcut triangulation
         *    - Drag-to-adjust cut plane for precise control
         *    - Floating parts removal to ensure clean geometry
         *
         * 3. QUALITY CONTROL CHECKS
         *    - Automated flatness detection with detailed metrics:
         *      ‚Ä¢ Contact area calculation (mm¬≤)
         *      ‚Ä¢ Height variation measurement (micrometers)
         *      ‚Ä¢ Minimum 3 vertices & planar surface validation
         *    - Visual feedback via viewport border color:
         *      ‚Ä¢ GREEN border = FLAT & ready for printing
         *      ‚Ä¢ RED border = NOT FLAT & needs adjustment
         *
         * 4. DUAL RENDER OUTPUT
         *    - Technical JPG Render (with quality control border):
         *      ‚Ä¢ Includes colored border indicating flatness status
         *      ‚Ä¢ Front view with reference man for scale verification
         *      ‚Ä¢ Used for internal QC and documentation
         *    - Production PNG Render (transparent, clean):
         *      ‚Ä¢ No borders or technical indicators
         *      ‚Ä¢ 15¬∞ tilted view for professional presentation
         *      ‚Ä¢ Transparent background for marketing/product pages
         *    - STL Export: Processed model ready for slicing
         *
         * 5. USER INTERFACE ORGANIZATION
         *    - Top-right overlay: Zoom controls & height adjustment (always accessible)
         *    - Top-left overlay: Cut mode controls (shows only when needed)
         *    - Bottom-right: Download button for all file types
         *    - Status indicator: Real-time flatness feedback
         *
         * WORKFLOW:
         * 1. Upload STL files (drag & drop or click to browse)
         * 2. Select scaling preset or adjust height manually
         * 3. Enable cut mode and adjust cut height to flatten bottom
         * 4. Apply cut - UI automatically hides after successful cut
         * 5. Verify flatness via green border and status details
         * 6. Download files: STL for printing, JPG for QC, PNG for production
         *
         * TECHNICAL NOTES:
         * - Three.js for 3D rendering and geometry manipulation
         * - Earcut library for robust polygon triangulation during cutting
         * - Orthographic camera for consistent scale representation
         * - All measurements in millimeters with precision to 0.1mm
         * - 28mm scale uses 1:56 ratio (standard tabletop gaming scale)
         *
         * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
         */

        const SCALE_28MM_RATIO = 56;
        const MONSTERS_PER_STAGE = 1;
        const MODELS_PER_PAGE = 12;
        let pendingFiles = [];
        let stages = [];
        let models = new Map();
        let currentScaleMode = '28mm';
        let currentPage = 1;
        let totalPages = 1;
        let currentTargetHeightMM = null;
        let processedModelData = []; // Store cleaned models after first processing
        function feetInchesToMM28mm(feet, inches) {
            const totalInches = (feet * 12) + inches;
            const realWorldMM = totalInches * 25.4;
            const mm28scale = realWorldMM / SCALE_28MM_RATIO;
            return mm28scale;
        }
        function mm28mmToFeetInches(mm28) {
            const realWorldMM = mm28 * SCALE_28MM_RATIO;
            const totalInches = realWorldMM / 25.4;
            const feet = Math.floor(totalInches / 12);
            const inches = totalInches % 12;
            return { feet, inches };
        }
        function inchesToMM(inches) {
            return inches * 25.4;
        }
        function mmToInches(mm) {
            return mm / 25.4;
        }
        function formatFeetInches(feet, inches) {
            if (feet === 0) return inches.toFixed(1) + '"';
            if (inches === 0 || inches < 0.1) return feet + "'";
            return feet + "' " + inches.toFixed(1) + '"';
        }
        function formatInches(inches) {
            return inches.toFixed(1) + '"';
        }
        function generateRandomSuffix() {
            return Math.floor(100000 + Math.random() * 900000).toString();
        }
        function updateLoadingProgress(percent, message) {
            const progressBar = document.getElementById('loadingProgressBar');
            const loadingMessage = document.getElementById('loadingMessage');
            if (progressBar) {
                progressBar.style.width = percent + '%';
                progressBar.textContent = Math.round(percent) + '%';
            }
            if (loadingMessage && message) {
                loadingMessage.textContent = message;
            }
        }
        class Stage {
            constructor(index, scaleMode = '28mm') {
                this.index = index;
                this.scaleMode = scaleMode;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.models = [];
                this.container = null;
                this.maxHeight = 0;
                this.groundY = 0;
                this.cameraOffset = { x: 0, y: 0 };
                this.zoomLevel = 1;
                this.baseFrustumSize = 70;
                this.flatnessStatus = new Map();
                this.manGroup = null;
                this.manDudeLabel3D = null;
                this.heightLabels = new Map();
                this.lights = {};
                this.viewMode = 'all';
                this.cutModeEnabled = false;
                this.cutCube = null;
                this.cutCubeLabel = null;
                this.cutHeight = 0.1;
                this.manZPosition = -25;
                this.manYRotation = 90;
                this.boundingBoxHelper = null;
                this.axisHelper = null;
                this.boundingBoxHelper = null;
                this.axesHelper = null;
            }
            init(container) {
                this.container = container;
                const width = container.clientWidth || 350;
                const height = width;
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x2a2a2a);
                const frustumSize = this.baseFrustumSize;
                this.camera = new THREE.OrthographicCamera(
                    frustumSize / -2, frustumSize / 2,
                    frustumSize / 2, frustumSize / -2,
                    -1000, 1000
                );
                this.camera.position.set(300, 0, 0);
                this.camera.lookAt(0, 0, 0);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
                this.renderer.setSize(width, height);
                this.renderer.shadowMap.enabled = false; // DISABLED - no shadow rendering at all
                container.appendChild(this.renderer.domElement);
                this.setupLighting();
                this.addGroundLine();
                this.addManOverlay();
                this.render();
            }
            toggleCutMode(enabled) {
                this.cutModeEnabled = enabled;
                if (enabled) {
                    if (!this.cutCube) {
                        this.createCutCube();
                    }
                    this.cutCube.visible = true;
                    if (this.cutCubeLabel) {
                        this.cutCubeLabel.visible = true;
                    }
                    this.updateCutCubeHeight(this.cutHeight);
                } else {
                    if (this.cutCube) {
                        this.cutCube.visible = false;
                    }
                    if (this.cutCubeLabel) {
                        this.cutCubeLabel.visible = false;
                    }
                }
                this.render();
            }
            createCutCube() {
                let maxSize = 200;
                if (this.models.length > 0) {
                    const box = new THREE.Box3();
                    this.models.forEach(modelData => {
                        modelData.mesh.updateMatrixWorld(true);
                        box.expandByObject(modelData.mesh);
                    });
                    if (!box.isEmpty()) {
                        const size = box.getSize(new THREE.Vector3());
                        maxSize = Math.max(size.x, size.z) * 3;
                    }
                }
                const cubeHeight = 100;
                const cubeGeometry = new THREE.BoxGeometry(maxSize, cubeHeight, maxSize);
                const cubeMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide,
                    depthTest: true,
                    depthWrite: false
                });
                this.cutCube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                this.cutCube.position.y = this.groundY + this.cutHeight - (cubeHeight / 2);
                this.cutCube.position.x = 0;
                this.cutCube.position.z = 0;
                this.cutCube.castShadow = false; // Cut cube should NOT cast shadows
                this.cutCube.receiveShadow = false;
                this.scene.add(this.cutCube);
                this.cutCube.visible = false;
                this.cutCubeHeight = cubeHeight;
                this.cutCubeWidth = maxSize;
                const labelText = `Cut Cube: ${maxSize.toFixed(1)}mm √ó ${maxSize.toFixed(1)}mm √ó ${cubeHeight.toFixed(1)}mm`;
                this.cutCubeLabel = this.createHeightLabel(labelText, '#ff9800');
                this.cutCubeLabel.position.set(0, this.groundY + this.cutHeight - cubeHeight - 5, 0);
                this.scene.add(this.cutCubeLabel);
                this.cutCubeLabel.visible = false;

                // Add drag functionality for cut cube
                this.setupCutCubeDragging();
            }
            setupCutCubeDragging() {
                if (!this.renderer || !this.camera) return;

                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();
                let isDragging = false;
                let dragStartY = 0;
                let cutHeightStart = 0;

                const onMouseDown = (event) => {
                    if (!this.cutModeEnabled || !this.cutCube || !this.cutCube.visible) return;

                    const rect = this.renderer.domElement.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                    raycaster.setFromCamera(mouse, this.camera);
                    const intersects = raycaster.intersectObject(this.cutCube);

                    if (intersects.length > 0) {
                        isDragging = true;
                        dragStartY = event.clientY;
                        cutHeightStart = this.cutHeight;
                        this.renderer.domElement.style.cursor = 'grabbing';
                        event.preventDefault();
                    }
                };

                const onMouseMove = (event) => {
                    if (!this.cutModeEnabled || !this.cutCube || !this.cutCube.visible) {
                        this.renderer.domElement.style.cursor = 'default';
                        return;
                    }

                    if (isDragging) {
                        // Calculate drag distance (invert Y because screen Y is opposite to 3D Y)
                        const deltaY = dragStartY - event.clientY;
                        // Scale factor: adjust sensitivity (0.1 means 10 pixels = 1mm)
                        const sensitivity = 0.1;
                        const newHeight = Math.max(0.1, Math.min(50, cutHeightStart + deltaY * sensitivity));

                        this.cutHeight = newHeight;
                        this.updateCutCubeHeight(newHeight);

                        // Update the UI display - find modelId from global models map
                        models.forEach((modelData, modelId) => {
                            if (modelData.stageIndex === this.index) {
                                const valueSpan = document.getElementById(`cut-height-value-${modelId}`);
                                if (valueSpan) {
                                    valueSpan.textContent = `${newHeight.toFixed(1)}mm`;
                                }
                            }
                        });
                        event.preventDefault();
                    } else {
                        // Check if mouse is over cut cube to show grab cursor
                        const rect = this.renderer.domElement.getBoundingClientRect();
                        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                        raycaster.setFromCamera(mouse, this.camera);
                        const intersects = raycaster.intersectObject(this.cutCube);

                        if (intersects.length > 0) {
                            this.renderer.domElement.style.cursor = 'grab';
                        } else {
                            this.renderer.domElement.style.cursor = 'default';
                        }
                    }
                };

                const onMouseUp = () => {
                    if (isDragging) {
                        isDragging = false;
                        this.renderer.domElement.style.cursor = 'grab';
                    }
                };

                // Attach event listeners
                this.renderer.domElement.addEventListener('mousedown', onMouseDown);
                this.renderer.domElement.addEventListener('mousemove', onMouseMove);
                this.renderer.domElement.addEventListener('mouseup', onMouseUp);
                this.renderer.domElement.addEventListener('mouseleave', onMouseUp);

                // Store references for cleanup if needed
                this.cutCubeDragHandlers = { onMouseDown, onMouseMove, onMouseUp };
            }
            updateCutCubeHeight(heightMM) {
                this.cutHeight = heightMM;
                if (this.cutCube) {
                    this.cutCube.position.y = this.groundY + heightMM - (this.cutCubeHeight / 2);
                    if (this.cutCubeLabel) {
                        this.cutCubeLabel.position.y = this.groundY + heightMM - this.cutCubeHeight - 5;
                    }
                    this.render();
                }
            }
            setupLighting() {
                // Key light - NO SHADOW RENDERING AT ALL
                this.lights.key = new THREE.DirectionalLight(0xffffff, 0.8);
                this.lights.key.position.set(30, 20, -150);
                this.lights.key.castShadow = false; // DISABLED - no shadow rendering
                this.scene.add(this.lights.key);
                
                // Fill light - NO SHADOW RENDERING AT ALL
                this.lights.fill = new THREE.DirectionalLight(0xffffff, 0.4);
                this.lights.fill.position.set(10, 5, 80);
                this.lights.fill.castShadow = false; // DISABLED - no shadow rendering
                this.scene.add(this.lights.fill);
            }
            addManOverlay() {
                this.add3DManFigure();
                setTimeout(() => {
                    this.updateManPosition();
                }, 100);
            }
            add3DManFigure() {
                const manHeightMM = 30.8;
                const headRadius = 2.0;
                const torsoHeight = 15.4;
                const torsoWidth = 8.6;
                const torsoDepth = 5.5;
                const legHeight = 14.6;
                const legWidth = 2.5;
                const legDepth = 2.5;
                const legSpacing = 0.6;
                const armHeight = 13.5;
                const armWidth = 1.5;
                const armDepth = 1.5;
                const headY = manHeightMM - headRadius;
                const torsoTopY = headY - headRadius;
                const torsoY = torsoTopY - (torsoHeight / 2);
                const legY = legHeight / 2;
                const skinMaterial = new THREE.MeshPhongMaterial({
                    color: 0xf4c8a8,
                    emissive: 0x2a3a4a,
                    emissiveIntensity: 0.35,
                    shininess: 3
                });
                const tealMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00CED1,
                    emissive: 0x2a3a4a,
                    emissiveIntensity: 0.35,
                    shininess: 3
                });
                const darkBlueMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00008B,
                    emissive: 0x2a3a4a,
                    emissiveIntensity: 0.35,
                    shininess: 3
                });
                this.manGroup = new THREE.Group();
                // Man figure should NOT cast shadows - only the main STL model casts shadows
                const head = new THREE.Mesh(
                    new THREE.SphereGeometry(headRadius, 16, 16),
                    skinMaterial
                );
                head.position.set(0, headY, 0);
                head.castShadow = false;
                this.manGroup.add(head);
                const torso = new THREE.Mesh(
                    new THREE.BoxGeometry(torsoWidth, torsoHeight, torsoDepth),
                    tealMaterial
                );
                torso.position.set(0, torsoY, 0);
                torso.castShadow = false;
                this.manGroup.add(torso);
                const leftLeg = new THREE.Mesh(
                    new THREE.BoxGeometry(legWidth, legHeight, legDepth),
                    darkBlueMaterial
                );
                leftLeg.position.set(-(legWidth / 2) - (legSpacing / 2), legY, 0);
                leftLeg.castShadow = false;
                this.manGroup.add(leftLeg);
                const rightLeg = new THREE.Mesh(
                    new THREE.BoxGeometry(legWidth, legHeight, legDepth),
                    darkBlueMaterial
                );
                rightLeg.position.set((legWidth / 2) + (legSpacing / 2), legY, 0);
                rightLeg.castShadow = false;
                this.manGroup.add(rightLeg);
                const leftArm = new THREE.Mesh(
                    new THREE.BoxGeometry(armWidth, armHeight, armDepth),
                    skinMaterial
                );
                leftArm.position.set(-(torsoWidth / 2) - (armWidth / 2), torsoTopY - (armHeight / 2), 0);
                leftArm.castShadow = false;
                this.manGroup.add(leftArm);
                const rightArm = new THREE.Mesh(
                    new THREE.BoxGeometry(armWidth, armHeight, armDepth),
                    skinMaterial
                );
                rightArm.position.set((torsoWidth / 2) + (armWidth / 2), torsoTopY - (armHeight / 2), 0);
                rightArm.castShadow = false;
                this.manGroup.add(rightArm);
                this.manGroup.position.set(0, 0, this.manZPosition);
                this.manGroup.rotation.y = this.manYRotation * Math.PI / 180;
                this.scene.add(this.manGroup);
                this.manFigureHeight = manHeightMM;
                const manLabelSprite = this.createHeightLabel("Man Dude 5'8\" (30.8mm)", '#6699cc');
                manLabelSprite.position.set(0, manHeightMM + 3, this.manZPosition);
                this.scene.add(manLabelSprite);
                this.manDudeLabel3D = manLabelSprite;
            }
            updateManPosition() {
                if (this.models.length > 0) {
                    const modelBox = new THREE.Box3();
                    this.models.forEach(modelData => {
                        modelData.mesh.updateMatrixWorld(true);
                        modelBox.expandByObject(modelData.mesh);
                    });
                    this.manGroup.updateMatrixWorld(true);
                    const manBox = new THREE.Box3().setFromObject(this.manGroup);
                    const manMaxZOffset = manBox.max.z - this.manGroup.position.z;
                    const newZPosition = modelBox.min.z - manMaxZOffset;
                    this.manGroup.position.z = newZPosition;
                    this.manZPosition = newZPosition;
                    if (this.manDudeLabel3D) {
                        this.manDudeLabel3D.position.z = newZPosition;
                        this.manDudeLabel3D.position.y = this.manFigureHeight + 3;
                    }
                    this.render();
                }
            }
            rotateMan(axis, degrees) {
                if (!this.manGroup) return;
                const radians = degrees * Math.PI / 180;
                if (axis === 'y') {
                    this.manYRotation = degrees;
                    this.manGroup.rotation.y = radians;
                }
                this.updateManPosition();
                this.render();
            }
            updateModelHeightLabelPosition(modelId) {
                const modelHeightLabelEl = document.getElementById(`model-height-label-${modelId}`);
                if (!modelHeightLabelEl || this.models.length === 0) return;
                const viewportSize = this.container.clientWidth || 350;
                const frustumHeight = this.baseFrustumSize / this.zoomLevel;
                const box = new THREE.Box3();
                this.models.forEach(modelData => {
                    box.expandByObject(modelData.mesh);
                });
                const topY = box.max.y;
                const topOffsetFromCenter = topY - this.cameraOffset.y;
                const topNormalizedY = -topOffsetFromCenter / frustumHeight;
                const topPixelFromTop = (viewportSize / 2) + (topNormalizedY * viewportSize);
                modelHeightLabelEl.style.top = (topPixelFromTop + 5) + 'px';
                modelHeightLabelEl.style.left = '10px';
            }
            updateCamera() {
                const frustumSize = this.baseFrustumSize / this.zoomLevel;
                this.camera.left = frustumSize / -2 + this.cameraOffset.x;
                this.camera.right = frustumSize / 2 + this.cameraOffset.x;
                this.camera.top = frustumSize / 2 + this.cameraOffset.y;
                this.camera.bottom = frustumSize / -2 + this.cameraOffset.y;
                this.camera.updateProjectionMatrix();
                if (this.models.length > 0) {
                    this.updateModelHeightLabelPosition(this.models[0].id);
                }
                this.render();
            }
            addGroundLine() {
                this.groundElements = [];
                const groundThickness = 2;
                const groundSize = 10000;
                const groundGeometry = new THREE.BoxGeometry(groundSize, groundThickness, groundSize);
                const groundMaterial = new THREE.MeshPhongMaterial({
                    color: 0xccaa44,
                    specular: 0x888888,
                    shininess: 30,
                    emissive: 0x332200,
                    emissiveIntensity: 0.1,
                    transparent: true,
                    opacity: 0.5
                });
                const groundBox = new THREE.Mesh(groundGeometry, groundMaterial);
                groundBox.position.y = this.groundY - (groundThickness / 2);
                groundBox.receiveShadow = true;
                groundBox.castShadow = false; // Ground should NOT cast shadows
                this.scene.add(groundBox);
                this.groundElements.push(groundBox);
                const lineGeometry = new THREE.BufferGeometry();
                const linePoints = [
                    new THREE.Vector3(0, this.groundY, -50000),
                    new THREE.Vector3(0, this.groundY, 50000)
                ];
                lineGeometry.setFromPoints(linePoints);
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: 0xffff00,
                    linewidth: 3
                });
                const groundLine = new THREE.Line(lineGeometry, lineMaterial);
                groundLine.renderOrder = 2;
                this.scene.add(groundLine);
                this.groundElements.push(groundLine);
                const darkGroundGeometry = new THREE.PlaneGeometry(100000, 50);
                const darkGroundMaterial = new THREE.MeshBasicMaterial({
                    color: 0x1a1a1a,
                    side: THREE.DoubleSide
                });
                const darkGround = new THREE.Mesh(darkGroundGeometry, darkGroundMaterial);
                darkGround.rotation.x = -Math.PI / 2;
                darkGround.position.y = -25;
                darkGround.castShadow = false; // Dark ground should NOT cast shadows
                darkGround.receiveShadow = false;
                this.scene.add(darkGround);
                this.groundElements.push(darkGround);
                const gridSpacing = this.scaleMode === '28mm' ? 5.5 : 25.4;
                for (let y = gridSpacing; y <= 10000; y += gridSpacing) {
                    const gridMaterial = new THREE.LineBasicMaterial({
                        color: 0xffffff,
                        linewidth: 2,
                        opacity: 0.6,
                        transparent: true
                    });
                    const gridPoints = [
                        new THREE.Vector3(0, y, -50000),
                        new THREE.Vector3(0, y, 50000)
                    ];
                    const gridGeometry = new THREE.BufferGeometry().setFromPoints(gridPoints);
                    const gridLine = new THREE.Line(gridGeometry, gridMaterial);
                    this.scene.add(gridLine);
                    this.groundElements.push(gridLine);
                }
            }
            alignToGround(mesh) {
                mesh.updateMatrixWorld(true);
                const geometry = mesh.geometry;
                const positions = geometry.attributes.position;
                let minY = Infinity;
                const matrix = mesh.matrixWorld;
                const vertex = new THREE.Vector3();
                for (let i = 0; i < positions.count; i++) {
                    vertex.fromBufferAttribute(positions, i);
                    vertex.applyMatrix4(matrix);
                    minY = Math.min(minY, vertex.y);
                }
                const offsetY = this.groundY - minY;
                mesh.position.y += offsetY;
                mesh.updateMatrixWorld(true);
            }
            checkFlatness(mesh) {
                mesh.updateMatrixWorld(true);
                const geometry = mesh.geometry;
                const positions = geometry.attributes.position;
                let minY = Infinity;
                const matrix = mesh.matrixWorld;
                const vertex = new THREE.Vector3();
                for (let i = 0; i < positions.count; i++) {
                    vertex.fromBufferAttribute(positions, i);
                    vertex.applyMatrix4(matrix);
                    minY = Math.min(minY, vertex.y);
                }
                const tolerance = 0.01;
                const bottomVertices = [];
                for (let i = 0; i < positions.count; i++) {
                    vertex.fromBufferAttribute(positions, i);
                    vertex.applyMatrix4(matrix);
                    if (Math.abs(vertex.y - minY) <= tolerance) {
                        bottomVertices.push({ x: vertex.x, y: vertex.y, z: vertex.z });
                    }
                }
                const vertexCount = bottomVertices.length;
                if (vertexCount < 3) {
                    return { isFlat: false, reason: "Insufficient vertices (need 3+)", vertexCount: vertexCount };
                }
                let minBottomY = Infinity, maxBottomY = -Infinity;
                let minX = Infinity, maxX = -Infinity;
                let minZ = Infinity, maxZ = -Infinity;
                bottomVertices.forEach(v => {
                    minBottomY = Math.min(minBottomY, v.y);
                    maxBottomY = Math.max(maxBottomY, v.y);
                    minX = Math.min(minX, v.x);
                    maxX = Math.max(maxX, v.x);
                    minZ = Math.min(minZ, v.z);
                    maxZ = Math.max(maxZ, v.z);
                });
                const yRange = maxBottomY - minBottomY;
                const isPlanar = yRange <= 0.01;
                const xSpan = maxX - minX;
                const zSpan = maxZ - minZ;
                const area = xSpan * zSpan;
                const hasGoodArea = area >= 4;
                const isFlat = vertexCount >= 3 && isPlanar && hasGoodArea;
                return {
                    isFlat: isFlat,
                    vertexCount: vertexCount,
                    yRange: yRange,
                    area: area,
                    reason: !isFlat ? this.getFlatnessFailureReason(vertexCount >= 3, isPlanar, hasGoodArea) : null
                };
            }
            getFlatnessFailureReason(hasEnoughVertices, isPlanar, hasGoodArea) {
                if (!hasEnoughVertices) return "Insufficient vertices (need 3+)";
                if (!isPlanar) return "Not planar (>0.01mm variation)";
                if (!hasGoodArea) return "Contact area too small (<4mm2)";
                return "Unknown";
            }
            createHeightLabel(text, color) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.font = 'bold 30px Arial';
                context.fillStyle = color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.strokeStyle = 'black';
                context.lineWidth = 3;
                context.strokeText(text, canvas.width / 2, canvas.height / 2);
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                const texture = new THREE.Texture(canvas);
                texture.needsUpdate = true;
                const spriteMaterial = new THREE.SpriteMaterial({
                    map: texture,
                    depthTest: false,
                    depthWrite: false
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(15, 4, 1);
                return sprite;
            }
            updateHeightLabel(modelId, mesh) {
                if (this.heightLabels.has(modelId)) {
                    const oldLabel = this.heightLabels.get(modelId);
                    this.scene.remove(oldLabel);
                }
                mesh.updateMatrixWorld(true);
                const box = new THREE.Box3().setFromObject(mesh);
                const heightMM = box.max.y - this.groundY;
                let heightText;
                if (this.scaleMode === '28mm') {
                    const { feet, inches } = mm28mmToFeetInches(heightMM);
                    heightText = `${formatFeetInches(feet, inches)} (${heightMM.toFixed(1)}mm)`;
                } else {
                    const inches = mmToInches(heightMM);
                    heightText = `${formatInches(inches)} (${heightMM.toFixed(1)}mm)`;
                }
                const color = '#ff4444';
                const label = this.createHeightLabel(heightText, color);
                label.position.set(
                    box.min.z + 5,
                    box.max.y - 3,
                    mesh.position.z
                );
                this.scene.add(label);
                this.heightLabels.set(modelId, label);
            }
            addMonster(mesh, modelId) {
                mesh.name = modelId;
                const material = new THREE.MeshPhongMaterial({
                    color: 0xfff0f0,
                    emissive: 0x3b350c,
                    emissiveIntensity: 0.35,
                    shininess: 3,
                    side: THREE.DoubleSide
                });
                mesh.material = material;
                
                // SHADOW SYSTEM: Only the main STL model casts shadows
                // This is the ONLY object in the scene with castShadow = true
                // Everything else (man, ground, lights, helpers) has castShadow = false
                mesh.castShadow = true;  // This model WILL cast a shadow
                mesh.receiveShadow = true; // This model CAN receive shadows
                
                this.scene.add(mesh);
                this.models.push({ mesh: mesh, id: modelId });
                this.alignToGround(mesh);
                const flatnessResult = this.checkFlatness(mesh);
                this.flatnessStatus.set(modelId, flatnessResult);
                this.updateFlatnessDisplay();
                this.updateHeightLabel(modelId, mesh);
                this.updateManPosition();
                this.fitAllModelsAndManInView();
                this.render();
            }
            updateFlatnessDisplay() {
                if (this.models.length === 0) return;
                const modelData = this.models[0];
                const flatness = this.flatnessStatus.get(modelData.id);
                const status = document.getElementById(`status-${this.index}`);
                const viewport = document.getElementById(`viewport-${modelData.id}`);

                if (status && flatness) {
                    if (flatness.isFlat) {
                        // Model is FLAT - show green border and detailed flatness info
                        status.textContent = `‚úì Flat: ${flatness.area.toFixed(0)}mm¬≤ contact area, ${(flatness.yRange * 1000).toFixed(2)}¬µm variation`;
                        status.className = 'alignment-status';
                        if (viewport) {
                            viewport.style.borderColor = '#4CAF50'; // Green border
                            viewport.style.borderWidth = '4px';
                        }
                    } else {
                        // Model is NOT FLAT - show red border and reason
                        status.textContent = `‚ö† Not Flat: ${flatness.reason}`;
                        status.className = 'alignment-status not-flat';
                        if (viewport) {
                            viewport.style.borderColor = '#f44336'; // Red border
                            viewport.style.borderWidth = '4px';
                        }
                    }
                }
            }
            fitAllModelsInView() {
                const box = new THREE.Box3();
                this.models.forEach(modelData => {
                    box.expandByObject(modelData.mesh);
                });
                if (box.isEmpty()) {
                    box.set(new THREE.Vector3(-30, 0, -30), new THREE.Vector3(30, 60, 30));
                }
                const size = box.getSize(new THREE.Vector3());
                const maxDimension = Math.max(size.y, size.z);
                const viewportSize = this.container.clientWidth || 350;
                const paddingPixels = 10;
                const usablePixels = viewportSize - (paddingPixels * 2);
                const frustumSize = maxDimension * (viewportSize / usablePixels);
                this.zoomLevel = this.baseFrustumSize / frustumSize;
                const center = box.getCenter(new THREE.Vector3());
                this.cameraOffset.x = -center.z;
                this.cameraOffset.y = box.min.y + (size.y / 2);
                this.updateCamera();
                if (this.models.length > 0) {
                    this.updateModelHeightLabelPosition(this.models[0].id);
                }
            }
            fitAllModelsAndManInView() {
                if (this.manGroup) this.manGroup.visible = true;
                if (this.manDudeLabel3D) this.manDudeLabel3D.visible = true;
                if (this.cutModeEnabled) {
                    if (this.cutCube) this.cutCube.visible = true;
                    if (this.cutCubeLabel) this.cutCubeLabel.visible = true;
                }
                if (this.groundElements) {
                    this.groundElements.forEach(element => {
                        element.visible = true;
                    });
                }
                this.heightLabels.forEach(label => {
                    label.visible = true;
                });
                this.scene.background = new THREE.Color(0x2a2a2a);
                this.renderer.setClearColor(0x2a2a2a, 1);
                this.viewMode = 'all';
                const box = new THREE.Box3();
                this.models.forEach(modelData => {
                    box.expandByObject(modelData.mesh);
                });
                if (this.manGroup) {
                    box.expandByObject(this.manGroup);
                }
                if (box.isEmpty()) {
                    box.set(new THREE.Vector3(-30, 0, -30), new THREE.Vector3(30, 60, 30));
                }
                const size = box.getSize(new THREE.Vector3());
                const maxDimension = Math.max(size.y, size.z);
                const viewportSize = this.container.clientWidth || 350;
                const paddingPixels = 10;
                const usablePixels = viewportSize - (paddingPixels * 2);
                const frustumSize = maxDimension * (viewportSize / usablePixels);
                this.zoomLevel = this.baseFrustumSize / frustumSize;
                const center = box.getCenter(new THREE.Vector3());
                this.cameraOffset.x = -center.z;
                this.cameraOffset.y = box.min.y + (size.y / 2);
                const frustumSizeCalc = this.baseFrustumSize / this.zoomLevel;
                this.camera.left = frustumSizeCalc / -2 + this.cameraOffset.x;
                this.camera.right = frustumSizeCalc / 2 + this.cameraOffset.x;
                this.camera.top = frustumSizeCalc / 2 + this.cameraOffset.y;
                this.camera.bottom = frustumSizeCalc / -2 + this.cameraOffset.y;
                this.camera.updateProjectionMatrix();
                this.camera.position.set(300, 0, 0);
                this.camera.lookAt(0, 0, 0);
                if (this.models.length > 0) {
                    this.updateModelHeightLabelPosition(this.models[0].id);
                }
                this.render();
            }
            fitSTLOnlyInView() {
                if (this.manGroup) this.manGroup.visible = false;
                if (this.manDudeLabel3D) this.manDudeLabel3D.visible = false;
                if (this.cutCube) this.cutCube.visible = false;
                if (this.cutCubeLabel) this.cutCubeLabel.visible = false;
                if (this.groundElements) {
                    this.groundElements.forEach(element => {
                        element.visible = false;
                    });
                }
                this.heightLabels.forEach(label => {
                    label.visible = false;
                });
                this.scene.background = null;
                this.renderer.setClearColor(0x000000, 0);
                this.viewMode = 'stl';
                const box = new THREE.Box3();
                this.models.forEach(modelData => {
                    modelData.mesh.updateMatrixWorld(true);
                    box.expandByObject(modelData.mesh);
                });
                if (!box.isEmpty()) {
                    const center = box.getCenter(new THREE.Vector3());
                    const tiltRadians = 15 * Math.PI / 180;
                    const distance = 300;
                    const camX = distance * Math.cos(tiltRadians);
                    const camY = center.y + distance * Math.sin(tiltRadians);
                    const camZ = center.z;
                    this.camera.position.set(camX, camY, camZ);
                    this.camera.lookAt(center.x, center.y, center.z);
                    this.camera.updateMatrixWorld();
                    const points = [
                        new THREE.Vector3(box.min.x, box.min.y, box.min.z),
                        new THREE.Vector3(box.max.x, box.min.y, box.min.z),
                        new THREE.Vector3(box.min.x, box.max.y, box.min.z),
                        new THREE.Vector3(box.max.x, box.max.y, box.min.z),
                        new THREE.Vector3(box.min.x, box.min.y, box.max.z),
                        new THREE.Vector3(box.max.x, box.min.y, box.max.z),
                        new THREE.Vector3(box.min.x, box.max.y, box.max.z),
                        new THREE.Vector3(box.max.x, box.max.y, box.max.z)
                    ];
                    const worldToCam = new THREE.Matrix4().copy(this.camera.matrixWorldInverse);
                    const camSpacePoints = points.map(p => p.clone().applyMatrix4(worldToCam));
                    let minX = Infinity, maxX = -Infinity;
                    let minY = Infinity, maxY = -Infinity;
                    camSpacePoints.forEach(p => {
                        minX = Math.min(minX, p.x);
                        maxX = Math.max(maxX, p.x);
                        minY = Math.min(minY, p.y);
                        maxY = Math.max(maxY, p.y);
                    });
                    const sizeX = maxX - minX;
                    const sizeY = maxY - minY;
                    const centerX = (minX + maxX) / 2;
                    const centerY = (minY + maxY) / 2;
                    const padding = 1.1;
                    const frustumWidth = sizeX * padding;
                    const frustumHeight = sizeY * padding;
                    const frustumSize = Math.max(frustumWidth, frustumHeight);
                    this.camera.left = centerX - frustumSize / 2;
                    this.camera.right = centerX + frustumSize / 2;
                    this.camera.top = centerY + frustumSize / 2;
                    this.camera.bottom = centerY - frustumSize / 2;
                    this.camera.updateProjectionMatrix();
                }
                this.render();
            }
            recenterCurrentView() {
                if (this.viewMode === 'stl') {
                    this.fitSTLOnlyInView();
                } else {
                    this.fitAllModelsAndManInView();
                }
            }
            createTempRenderer(width, height) {
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.setSize(width, height);
                return renderer;
            }
            takeScreenshot() {
                // JPG Technical Render - includes colored border based on flatness status
                const width = 1080;
                const height = 1080;
                const tempRenderer = this.createTempRenderer(width, height);
                const clearColor = new THREE.Color();
                this.renderer.getClearColor(clearColor);
                const clearAlpha = this.renderer.getClearAlpha();
                tempRenderer.setClearColor(clearColor, clearAlpha);
                this.scene.background = new THREE.Color(0x2a2a2a);
                tempRenderer.render(this.scene, this.camera);

                // Add flatness status border to the technical JPG render
                const canvas = tempRenderer.domElement;
                const ctx = canvas.getContext('2d');

                // Determine border color based on flatness status
                let borderColor = '#444'; // Default gray
                if (this.models.length > 0) {
                    const modelData = this.models[0];
                    const flatness = this.flatnessStatus.get(modelData.id);
                    if (flatness) {
                        borderColor = flatness.isFlat ? '#4CAF50' : '#f44336'; // Green if flat, red if not
                    }
                }

                // Draw border on canvas (technical render quality control indicator)
                const borderWidth = 8; // 8px border at 1080px resolution
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = borderWidth;
                ctx.strokeRect(borderWidth / 2, borderWidth / 2, width - borderWidth, height - borderWidth);

                const dataURL = canvas.toDataURL('image/png');
                tempRenderer.dispose();
                return dataURL;
            }
            takeTransparentTiltedScreenshot() {
                const originalBackground = this.scene.background;
                const originalClearColor = new THREE.Color();
                this.renderer.getClearColor(originalClearColor);
                const originalClearAlpha = this.renderer.getClearAlpha();
                const originalCameraPosition = this.camera.position.clone();
                const originalCameraRotation = this.camera.rotation.clone();
                const originalLeft = this.camera.left;
                const originalRight = this.camera.right;
                const originalTop = this.camera.top;
                const originalBottom = this.camera.bottom;
                const manVisible = this.manGroup ? this.manGroup.visible : false;
                const labelVisible = this.manDudeLabel3D ? this.manDudeLabel3D.visible : false;
                const groundVisibles = this.groundElements ? this.groundElements.map(el => el.visible) : [];
                const heightLabelsVisibles = Array.from(this.heightLabels.values()).map(label => label.visible);
                if (this.manGroup) this.manGroup.visible = false;
                if (this.manDudeLabel3D) this.manDudeLabel3D.visible = false;
                if (this.groundElements) {
                    this.groundElements.forEach(element => {
                        element.visible = false;
                    });
                }
                this.heightLabels.forEach(label => {
                    label.visible = false;
                });
                const box = new THREE.Box3();
                this.models.forEach(modelData => {
                    modelData.mesh.updateMatrixWorld(true);
                    box.expandByObject(modelData.mesh);
                });
                let dataURL = '';
                if (!box.isEmpty()) {
                    const center = box.getCenter(new THREE.Vector3());
                    const tiltRadians = 15 * Math.PI / 180;
                    const distance = 300;
                    const camX = distance * Math.cos(tiltRadians);
                    const camY = center.y + distance * Math.sin(tiltRadians);
                    const camZ = center.z;
                    this.camera.position.set(camX, camY, camZ);
                    this.camera.lookAt(center.x, center.y, center.z);
                    this.camera.updateMatrixWorld();
                    const points = [
                        new THREE.Vector3(box.min.x, box.min.y, box.min.z),
                        new THREE.Vector3(box.max.x, box.min.y, box.min.z),
                        new THREE.Vector3(box.min.x, box.max.y, box.min.z),
                        new THREE.Vector3(box.max.x, box.max.y, box.min.z),
                        new THREE.Vector3(box.min.x, box.min.y, box.max.z),
                        new THREE.Vector3(box.max.x, box.min.y, box.max.z),
                        new THREE.Vector3(box.min.x, box.max.y, box.max.z),
                        new THREE.Vector3(box.max.x, box.max.y, box.max.z)
                    ];
                    const worldToCam = new THREE.Matrix4().copy(this.camera.matrixWorldInverse);
                    const camSpacePoints = points.map(p => p.clone().applyMatrix4(worldToCam));
                    let minX = Infinity, maxX = -Infinity;
                    let minY = Infinity, maxY = -Infinity;
                    camSpacePoints.forEach(p => {
                        minX = Math.min(minX, p.x);
                        maxX = Math.max(maxX, p.x);
                        minY = Math.min(minY, p.y);
                        maxY = Math.max(maxY, p.y);
                    });
                    const sizeX = maxX - minX;
                    const sizeY = maxY - minY;
                    const padding = 1.0;
                    const frustumWidth = sizeX * padding;
                    const frustumHeight = sizeY * padding;
                    const maxPixel = 1080;
                    const maxDim = Math.max(frustumWidth, frustumHeight);
                    const pixelWidth = Math.round((frustumWidth / maxDim) * maxPixel);
                    const pixelHeight = Math.round((frustumHeight / maxDim) * maxPixel);
                    const tempRenderer = this.createTempRenderer(pixelWidth, pixelHeight);
                    this.scene.background = null;
                    tempRenderer.setClearColor(0x000000, 0);
                    this.camera.left = minX;
                    this.camera.right = maxX;
                    this.camera.top = maxY;
                    this.camera.bottom = minY;
                    this.camera.updateProjectionMatrix();
                    tempRenderer.render(this.scene, this.camera);
                    dataURL = tempRenderer.domElement.toDataURL('image/png');
                    tempRenderer.dispose();
                }
                this.scene.background = originalBackground;
                this.renderer.setClearColor(originalClearColor, originalClearAlpha);
                this.camera.position.copy(originalCameraPosition);
                this.camera.rotation.copy(originalCameraRotation);
                this.camera.left = originalLeft;
                this.camera.right = originalRight;
                this.camera.top = originalTop;
                this.camera.bottom = originalBottom;
                this.camera.updateProjectionMatrix();
                if (this.manGroup) this.manGroup.visible = manVisible;
                if (this.manDudeLabel3D) this.manDudeLabel3D.visible = labelVisible;
                if (this.groundElements) {
                    this.groundElements.forEach((element, idx) => {
                        element.visible = groundVisibles[idx];
                    });
                }
                Array.from(this.heightLabels.values()).forEach((label, idx) => {
                    label.visible = heightLabelsVisibles[idx];
                });
                this.render();
                return dataURL;
            }
            render() {
                if (this.renderer && this.scene && this.camera) {
                    this.renderer.render(this.scene, this.camera);
                }
            }
            showBoundingBoxAndAxes(mesh, color = 0xFFD700) {
                this.hideBoundingBoxAndAxes();
                const box = new THREE.Box3().setFromObject(mesh);
                this.boundingBoxHelper = new THREE.Box3Helper(box, color);
                this.boundingBoxHelper.castShadow = false; // Helpers should NOT cast shadows
                this.scene.add(this.boundingBoxHelper);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                this.axesHelper = new THREE.AxesHelper(maxDim * 0.7);
                this.axesHelper.position.copy(mesh.position);
                this.axesHelper.rotation.copy(mesh.rotation);
                this.axesHelper.castShadow = false; // Helpers should NOT cast shadows
                this.scene.add(this.axesHelper);
                this.render();
            }
            hideBoundingBoxAndAxes() {
                if (this.boundingBoxHelper) {
                    this.scene.remove(this.boundingBoxHelper);
                    this.boundingBoxHelper = null;
                }
                if (this.axesHelper) {
                    this.scene.remove(this.axesHelper);
                    this.axesHelper = null;
                }
                this.render();
            }
        }
        function removeFloatingParts(geometry) {
            const positions = geometry.attributes.position;
            const triangleCount = positions.count / 3;
            if (triangleCount === 0) return geometry;
            const vertexToTriangles = new Map();
            for (let i = 0; i < triangleCount; i++) {
                for (let j = 0; j < 3; j++) {
                    const vertexIndex = i * 3 + j;
                    const x = positions.getX(vertexIndex);
                    const y = positions.getY(vertexIndex);
                    const z = positions.getZ(vertexIndex);
                    const key = `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`;
                    if (!vertexToTriangles.has(key)) {
                        vertexToTriangles.set(key, []);
                    }
                    vertexToTriangles.get(key).push(i);
                }
            }
            const visited = new Set();
            const components = [];
            for (let startTriangle = 0; startTriangle < triangleCount; startTriangle++) {
                if (visited.has(startTriangle)) continue;
                const component = [];
                const queue = [startTriangle];
                visited.add(startTriangle);
                while (queue.length > 0) {
                    const triangleIdx = queue.shift();
                    component.push(triangleIdx);
                    for (let j = 0; j < 3; j++) {
                        const vertexIndex = triangleIdx * 3 + j;
                        const x = positions.getX(vertexIndex);
                        const y = positions.getY(vertexIndex);
                        const z = positions.getZ(vertexIndex);
                        const key = `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`;
                        const connectedTriangles = vertexToTriangles.get(key) || [];
                        for (const connectedIdx of connectedTriangles) {
                            if (!visited.has(connectedIdx)) {
                                visited.add(connectedIdx);
                                queue.push(connectedIdx);
                            }
                        }
                    }
                }
                components.push(component);
            }
            if (components.length <= 1) {
                console.log('‚úÖ Single component found - no floating parts');
                return geometry;
            }
            let largestComponent = components[0];
            for (const component of components) {
                if (component.length > largestComponent.length) {
                    largestComponent = component;
                }
            }
            console.log(`üßπ Removing floating parts: Found ${components.length} components, keeping largest with ${largestComponent.length} triangles`);
            const newVertices = [];
            const newNormals = [];
            const normals = geometry.attributes.normal;
            for (const triangleIdx of largestComponent) {
                for (let j = 0; j < 3; j++) {
                    const vertexIndex = triangleIdx * 3 + j;
                    newVertices.push(
                        positions.getX(vertexIndex),
                        positions.getY(vertexIndex),
                        positions.getZ(vertexIndex)
                    );
                    if (normals) {
                        newNormals.push(
                            normals.getX(vertexIndex),
                            normals.getY(vertexIndex),
                            normals.getZ(vertexIndex)
                        );
                    }
                }
            }
            const cleanGeometry = new THREE.BufferGeometry();
            cleanGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(newVertices), 3));
            if (newNormals.length > 0) {
                cleanGeometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(newNormals), 3));
            } else {
                cleanGeometry.computeVertexNormals();
            }
            cleanGeometry.computeBoundingBox();
            if (newVertices.length === 0) {
                console.warn('‚ö†Ô∏è Floating parts removal resulted in empty geometry - keeping original');
                return geometry;
            }
            return cleanGeometry;
        }
        function parseSTL(buffer) {
            try {
                const dataView = new DataView(buffer);
                const n_faces = dataView.getUint32(80, true);
                const expect = 80 + 4 + (n_faces * 50);
                if (expect === buffer.byteLength) {
                    return parseBinarySTL(buffer);
                } else {
                    const decoder = new TextDecoder('utf-8');
                    const text = decoder.decode(buffer.slice(0, 1000));
                    if (text.toLowerCase().indexOf('solid') === 0 || text.indexOf('facet') !== -1) {
                        return parseASCIISTL(decoder.decode(buffer));
                    }
                    return parseBinarySTL(buffer);
                }
            } catch (e) {
                throw new Error('Failed to parse STL file: ' + e.message);
            }
        }
        function parseBinarySTL(buffer) {
            const geometry = new THREE.BufferGeometry();
            const dataView = new DataView(buffer);
            let offset = 80;
            const triangles = dataView.getUint32(offset, true);
            offset += 4;
            if (triangles === 0) {
                throw new Error('STL file contains no triangles');
            }
            const expectedSize = 84 + (triangles * 50);
            if (buffer.byteLength < expectedSize) {
                throw new Error('STL file is truncated or corrupted');
            }
            const vertices = new Float32Array(triangles * 9);
            const normals = new Float32Array(triangles * 9);
            for (let i = 0; i < triangles; i++) {
                const nx = dataView.getFloat32(offset, true);
                const ny = dataView.getFloat32(offset + 4, true);
                const nz = dataView.getFloat32(offset + 8, true);
                offset += 12;
                for (let j = 0; j < 3; j++) {
                    const idx = i * 9 + j * 3;
                    vertices[idx] = dataView.getFloat32(offset, true);
                    vertices[idx + 1] = dataView.getFloat32(offset + 4, true);
                    vertices[idx + 2] = dataView.getFloat32(offset + 8, true);
                    normals[idx] = nx;
                    normals[idx + 1] = ny;
                    normals[idx + 2] = nz;
                    offset += 12;
                }
                offset += 2;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
            return geometry;
        }
        function parseASCIISTL(text) {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const normals = [];
            const lines = text.split('\n');
            let normal = null;
            let tempVertices = [];
            for (let line of lines) {
                line = line.trim();
                if (line.startsWith('facet normal')) {
                    const match = line.match(/facet\s+normal\s+([\-\+]?\d*\.?\d+(?:[eE][\-\+]?\d+)?)\s+([\-\+]?\d*\.?\d+(?:[eE][\-\+]?\d+)?)\s+([\-\+]?\d*\.?\d+(?:[eE][\-\+]?\d+)?)/);
                    if (match) normal = [parseFloat(match[1]), parseFloat(match[2]), parseFloat(match[3])];
                } else if (line.startsWith('vertex')) {
                    const match = line.match(/vertex\s+([\-\+]?\d*\.?\d+(?:[eE][\-\+]?\d+)?)\s+([\-\+]?\d*\.?\d+(?:[eE][\-\+]?\d+)?)\s+([\-\+]?\d*\.?\d+(?:[eE][\-\+]?\d+)?)/);
                    if (match) tempVertices.push([parseFloat(match[1]), parseFloat(match[2]), parseFloat(match[3])]);
                } else if (line.startsWith('endfacet') && tempVertices.length === 3) {
                    if (!normal) {
                        const v1 = tempVertices[0];
                        const v2 = tempVertices[1];
                        const v3 = tempVertices[2];
                        const ax = v2[0] - v1[0], ay = v2[1] - v1[1], az = v2[2] - v1[2];
                        const bx = v3[0] - v1[0], by = v3[1] - v1[1], bz = v3[2] - v1[2];
                        const nx = ay * bz - az * by;
                        const ny = az * bx - ax * bz;
                        const nz = ax * by - ay * bx;
                        const len = Math.sqrt(nx * nx + ny * ny + nz * nz);
                        normal = [nx / len, ny / len, nz / len];
                    }
                    for (let v of tempVertices) {
                        vertices.push(...v);
                        normals.push(...normal);
                    }
                    tempVertices = [];
                    normal = null;
                }
            }
            if (vertices.length === 0) {
                throw new Error('No vertices found in ASCII STL file');
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
            geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3));
            return geometry;
        }
        function setupDragAndDrop() {
            const dropZone = document.getElementById('dropZone');
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                handleFiles(e.dataTransfer.files);
            });
            dropZone.addEventListener('click', () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.stl';
                input.multiple = true;
                input.onchange = (e) => handleFiles(e.target.files);
                input.click();
            });
        }
        function handleFiles(files) {
            const stlFiles = Array.from(files).filter(f => f.name.toLowerCase().endsWith('.stl'));
            if (stlFiles.length === 0) {
                return;
            }
            pendingFiles.push(...stlFiles);
            processedModelData = []; // Clear cache when new files added
            updateFileList();
        }
        function updateFileList() {
            const fileList = document.getElementById('fileList');
            const fileListContent = document.getElementById('fileListContent');
            fileListContent.innerHTML = '';
            pendingFiles.forEach((file, index) => {
                const item = document.createElement('div');
                item.className = 'file-item';
                item.innerHTML = `<span>${file.name}</span><button onclick="removeFile(${index})">‚úï</button>`;
                fileListContent.appendChild(item);
            });
            const hasFiles = pendingFiles.length > 0;
            fileList.style.display = hasFiles ? 'block' : 'none';
            ['processNoScale', 'process32mm', 'process9ft', 'process12ft', 'process100mm', 'process300mm', 'clearAll'].forEach(id => {
                document.getElementById(id).disabled = !hasFiles;
            });
            if (hasFiles) {
                totalPages = Math.ceil(pendingFiles.length / MODELS_PER_PAGE);
                const pageDisplay = document.getElementById('pageDisplay');
                if (pageDisplay) {
                    pageDisplay.textContent = `Page 1 / ${totalPages}`;
                }
            } else {
                totalPages = 1;
                currentPage = 1;
            }
            updateModelCount();
        }
        window.removeFile = function(index) {
            pendingFiles.splice(index, 1);
            processedModelData = []; // Clear cache since indices changed
            updateFileList();
        };
        window.applyCutToModel = applyCutToModel;
        function clearAll() {
            if (!confirm('Clear all models?')) return;
            pendingFiles = [];
            processedModelData = []; // Clear cached processed data
            currentPage = 1;
            totalPages = 1;
            stages.forEach(stage => {
                if (stage.renderer) {
                    stage.renderer.dispose();
                }
            });
            stages = [];
            models.clear();
            document.getElementById('stages-container').innerHTML = '';
            document.getElementById('fileList').style.display = 'none';
            updateFileList();
            document.getElementById('exportEverything').disabled = true;
            updateModelCount();
        }
        async function processWithScale(targetHeightMM, scaleMode, buttonId) {
            const loading = document.getElementById('loading');
            const errorMsg = document.getElementById('errorMessage');
            if (pendingFiles.length === 0) {
                errorMsg.textContent = 'Please upload at least one STL file.';
                errorMsg.style.display = 'block';
                return;
            }

            // Check if we have models already loaded on the current page
            const hasExistingModels = models.size > 0;

            if (hasExistingModels) {
                // Just rescale existing models instead of reloading
                console.log('üîÑ Rescaling existing models to new target height');
                loading.style.display = 'block';
                updateLoadingProgress(50, 'Rescaling models...');

                // Update target for future pages
                currentScaleMode = scaleMode;
                currentTargetHeightMM = targetHeightMM;

                // Rescale all visible models
                models.forEach((modelData, modelId) => {
                    let newScale;
                    if (targetHeightMM === null) {
                        newScale = 1.0; // No scaling
                    } else {
                        if (scaleMode === '28mm') {
                            newScale = targetHeightMM / modelData.originalHeight;
                        } else {
                            newScale = targetHeightMM / modelData.originalMaxDimension;
                        }
                    }

                    // Update the model scale
                    modelData.scale = newScale;
                    modelData.scaleMode = scaleMode;
                    modelData.mesh.scale.set(newScale, newScale, newScale);
                    modelData.mesh.updateMatrixWorld(true);

                    // Realign to ground and update visuals
                    const stageIndex = modelData.stageIndex;
                    if (stages[stageIndex]) {
                        stages[stageIndex].alignToGround(modelData.mesh);
                        stages[stageIndex].recenterCurrentView();
                        stages[stageIndex].updateManPosition();
                        stages[stageIndex].updateHeightLabel(modelId, modelData.mesh);
                    }

                    // Update UI
                    updateAllUIForModel(modelId);
                });

                loading.style.display = 'none';
                checkExportButtons();
                console.log('‚úÖ Rescaling complete');
                return;
            }

            // First time processing - load the models
            loading.style.display = 'block';
            errorMsg.style.display = 'none';
            const alreadyProcessed = processedModelData.length === pendingFiles.length;
            if (alreadyProcessed) {
                updateLoadingProgress(0, 'Rescaling existing models...');
                console.log('‚ôªÔ∏è Reusing already-processed models (skipping STL parse & floating removal)');
                console.log(`üì¶ Cache hit: ${processedModelData.length} models available`);
                const modelCountDisplay = document.getElementById('modelCountDisplay');
                if (modelCountDisplay) {
                    const originalText = modelCountDisplay.textContent;
                    modelCountDisplay.textContent = '‚ôªÔ∏è Using cached models (fast!)';
                    modelCountDisplay.style.color = '#FFC107';
                    setTimeout(() => {
                        modelCountDisplay.textContent = originalText;
                        modelCountDisplay.style.color = '#4CAF50';
                    }, 2000);
                }
            } else {
                updateLoadingProgress(0, 'Starting...');
                console.log('üÜï First processing - will parse STL and remove floating parts');
            }
            currentScaleMode = scaleMode;
            currentTargetHeightMM = targetHeightMM;
            currentPage = 1;
            totalPages = Math.ceil(pendingFiles.length / MODELS_PER_PAGE);
            stages.forEach(stage => {
                if (stage.renderer) {
                    stage.renderer.dispose();
                }
            });
            stages = [];
            models.clear();
            document.getElementById('stages-container').innerHTML = '';
            try {
                await processCurrentPage();
                loading.style.display = 'none';
                checkExportButtons();
                updatePageDisplay();
            } catch (error) {
                errorMsg.textContent = 'Error processing models: ' + error.message;
                errorMsg.style.display = 'block';
                loading.style.display = 'none';
            }
        }
        async function processCurrentPage() {
            const loading = document.getElementById('loading');
            loading.style.display = 'block';
            const alreadyProcessed = processedModelData.length === pendingFiles.length;
            if (alreadyProcessed) {
                updateLoadingProgress(0, 'Loading page (using cached models)...');
            } else {
                updateLoadingProgress(0, 'Loading page...');
            }
            stages.forEach(stage => {
                if (stage.renderer) {
                    stage.renderer.dispose();
                }
            });
            stages = [];
            models.clear();
            document.getElementById('stages-container').innerHTML = '';
            const startIdx = (currentPage - 1) * MODELS_PER_PAGE;
            const endIdx = Math.min(startIdx + MODELS_PER_PAGE, pendingFiles.length);
            const filesToProcess = pendingFiles.slice(startIdx, endIdx);
            try {
                await processModels(filesToProcess, currentTargetHeightMM, currentScaleMode, startIdx);
                loading.style.display = 'none';
                updatePageDisplay();
                checkExportButtons();
            } catch (error) {
                loading.style.display = 'none';
                const errorMsg = document.getElementById('errorMessage');
                errorMsg.textContent = 'Error loading page: ' + error.message;
                errorMsg.style.display = 'block';
            }
        }
        function updatePageDisplay() {
            const startIdx = (currentPage - 1) * MODELS_PER_PAGE + 1;
            const endIdx = Math.min(currentPage * MODELS_PER_PAGE, pendingFiles.length);
            const total = pendingFiles.length;
            const modelCountDisplay = document.getElementById('modelCountDisplay');
            if (modelCountDisplay) {
                modelCountDisplay.textContent = `${startIdx}-${endIdx} / ${total} models`;
            }
            const footerModelCount = document.getElementById('footerModelCount');
            if (footerModelCount) {
                footerModelCount.textContent = `Showing ${startIdx}-${endIdx} of ${total} total models`;
            }
            const pageDisplay = document.getElementById('pageDisplay');
            if (pageDisplay) {
                pageDisplay.textContent = `Page ${currentPage} of ${totalPages}`;
            }
            const prevBtn = document.getElementById('prevPage');
            const nextBtn = document.getElementById('nextPage');
            if (prevBtn) prevBtn.disabled = currentPage <= 1;
            if (nextBtn) nextBtn.disabled = currentPage >= totalPages;
        }
        async function downloadAllModelsOnCurrentPage() {
            console.log('üì• Downloading all models on current page...');
            const modelIds = Array.from(models.keys());
            for (let i = 0; i < modelIds.length; i++) {
                const modelId = modelIds[i];
                console.log(`Downloading ${i + 1}/${modelIds.length}: ${modelId}`);
                downloadModelAndScreenshot(modelId);
                // Small delay between downloads to prevent browser overload
                if (i < modelIds.length - 1) {
                    await new Promise(r => setTimeout(r, 500));
                }
            }
            console.log('‚úÖ All downloads initiated');
        }
        async function goToPreviousPage() {
            if (currentPage > 1) {
                // Download all models on current page before switching
                await downloadAllModelsOnCurrentPage();
                currentPage--;
                await processCurrentPage();
            }
        }
        async function goToNextPage() {
            if (currentPage < totalPages) {
                // Download all models on current page before switching
                await downloadAllModelsOnCurrentPage();
                currentPage++;
                await processCurrentPage();
            }
        }
        function removeModel(modelId) {
            if (!confirm('Are you sure you want to remove this model?')) {
                return;
            }

            console.log('üóëÔ∏è Removing model:', modelId);

            // Get the model data before removing
            const modelData = models.get(modelId);
            if (!modelData) {
                console.warn('Model not found:', modelId);
                return;
            }

            // Dispose of Three.js resources
            if (modelData.mesh) {
                if (modelData.mesh.geometry) {
                    modelData.mesh.geometry.dispose();
                }
                if (modelData.mesh.material) {
                    if (Array.isArray(modelData.mesh.material)) {
                        modelData.mesh.material.forEach(m => m.dispose());
                    } else {
                        modelData.mesh.material.dispose();
                    }
                }
            }

            // Dispose of the stage renderer
            const stageIndex = modelData.stageIndex;
            if (stages[stageIndex]) {
                if (stages[stageIndex].renderer) {
                    stages[stageIndex].renderer.dispose();
                }
                stages[stageIndex] = null;
            }

            // Remove from models map
            models.delete(modelId);

            // Remove the card from DOM
            const card = document.getElementById(`card-${modelId}`);
            if (card) {
                card.remove();
            }

            // Check if we need to update export buttons
            checkExportButtons();

            console.log('‚úÖ Model removed successfully');
        }
        async function processModels(filesToProcess, targetHeightMM, scaleMode, startIdx) {
            const totalFiles = filesToProcess.length;
            // Check if we already have processed data for these files
            const alreadyProcessed = processedModelData.length === pendingFiles.length;
            for (let i = 0; i < totalFiles; i++) {
                const file = filesToProcess[i];
                const globalIndex = startIdx + i;
                const stageIndex = i; // Stage index for this page
                let monsterData;
                if (alreadyProcessed && processedModelData[globalIndex]) {
                    // Reuse already-processed model data
                    const progress = ((i + 1) / totalFiles) * 100;
                    updateLoadingProgress(progress, `Loading model ${i + 1}/${totalFiles}: ${file.name}`);
                    const cachedData = processedModelData[globalIndex];
                    // Clone the geometry (don't reuse the same instance)
                    const geometry = cachedData.geometry.clone();
                    const material = new THREE.MeshPhongMaterial({
                        color: 0xfff0f0,
                        emissive: 0x3b350c,
                        emissiveIntensity: 0.35,
                        shininess: 3,
                        side: THREE.DoubleSide
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    monsterData = {
                        mesh: mesh,
                        geometry: geometry,
                        filename: cachedData.filename,
                        originalHeight: cachedData.originalHeight,
                        originalWidth: cachedData.originalWidth,
                        originalDepth: cachedData.originalDepth,
                        originalMaxDimension: cachedData.originalMaxDimension
                    };
                } else {
                    // First-time processing: parse STL and remove floating parts
                    const progress = ((i + 1) / totalFiles) * 100;
                    updateLoadingProgress(progress, `Processing ${i + 1}/${totalFiles}: ${file.name}`);
                    try {
                        const buffer = await file.arrayBuffer();
                        let geometry = parseSTL(buffer);
                        if (!geometry || geometry.attributes.position.count === 0) {
                            continue;
                        }
                        const globalRemoveFloating = document.getElementById('globalRemoveFloating');
                        if (globalRemoveFloating && globalRemoveFloating.checked) {
                            const cleanedGeometry = removeFloatingParts(geometry);
                            if (cleanedGeometry !== geometry) {
                                geometry.dispose();
                                geometry = cleanedGeometry;
                            }
                        }
                        geometry.rotateX(-Math.PI / 2);
                        geometry.center();
                        geometry.computeBoundingBox();
                        const box = geometry.boundingBox;
                        const size = box.getSize(new THREE.Vector3());
                        const material = new THREE.MeshPhongMaterial({
                            color: 0xfff0f0,
                            emissive: 0x3b350c,
                            emissiveIntensity: 0.35,
                            shininess: 3,
                            side: THREE.DoubleSide
                        });
                        const mesh = new THREE.Mesh(geometry, material);
                        const maxDimension = Math.max(size.x, size.y, size.z);
                        monsterData = {
                            mesh: mesh,
                            geometry: geometry,
                            filename: file.name,
                            originalHeight: size.y,
                            originalWidth: size.x,
                            originalDepth: size.z,
                            originalMaxDimension: maxDimension
                        };
                        // Store in cache for future use
                        processedModelData[globalIndex] = {
                            geometry: geometry.clone(), // Store a clone for reuse
                            filename: file.name,
                            originalHeight: size.y,
                            originalWidth: size.x,
                            originalDepth: size.z,
                            originalMaxDimension: maxDimension
                        };
                    } catch (e) {
                        console.error('Error processing file:', file.name, e);
                        continue;
                    }
                }
                // IMMEDIATELY create and display the card for this model
                if (monsterData) {
                    await createModelCard(monsterData, stageIndex, targetHeightMM, scaleMode);
                }
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            updateLoadingProgress(100, 'Complete!');
            updateModelCount();
        }
        async function createModelCard(monsterData, stageIndex, targetHeightMM, scaleMode) {
            const modelId = `stage${stageIndex}_monster${stageIndex}`;
            const modelName = monsterData.filename.replace(/\.stl$/i, '');
            const stage = new Stage(stageIndex, scaleMode);
            const card = document.createElement('div');
            card.className = 'model-card';
            card.id = `card-${modelId}`;
            card.style.position = 'relative';

            const title = document.createElement('div');
            title.className = 'model-title';
            title.textContent = modelName;
            card.appendChild(title);

            // Delete button in top-right corner
            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = '‚úï';
            deleteBtn.title = 'Remove this model';
            deleteBtn.style.position = 'absolute';
            deleteBtn.style.top = '10px';
            deleteBtn.style.right = '10px';
            deleteBtn.style.width = '30px';
            deleteBtn.style.height = '30px';
            deleteBtn.style.padding = '0';
            deleteBtn.style.backgroundColor = '#f44336';
            deleteBtn.style.color = 'white';
            deleteBtn.style.border = 'none';
            deleteBtn.style.borderRadius = '50%';
            deleteBtn.style.cursor = 'pointer';
            deleteBtn.style.fontSize = '18px';
            deleteBtn.style.fontWeight = 'bold';
            deleteBtn.style.lineHeight = '1';
            deleteBtn.style.zIndex = '100';
            deleteBtn.style.transition = 'all 0.2s';
            deleteBtn.onmouseover = () => {
                deleteBtn.style.backgroundColor = '#d32f2f';
                deleteBtn.style.transform = 'scale(1.1)';
            };
            deleteBtn.onmouseout = () => {
                deleteBtn.style.backgroundColor = '#f44336';
                deleteBtn.style.transform = 'scale(1)';
            };
            deleteBtn.onclick = () => removeModel(modelId);
            card.appendChild(deleteBtn);

            // Height controls OUTSIDE viewport - displayed above the canvas
            const heightControlsWrapper = document.createElement('div');
            heightControlsWrapper.id = `height-controls-wrapper-${modelId}`;
            heightControlsWrapper.style.marginBottom = '10px';
            card.appendChild(heightControlsWrapper);

            const viewport = document.createElement('div');
            viewport.className = 'viewport';
            viewport.id = `viewport-${modelId}`;
            viewport.style.border = '3px solid #444'; // Default border, will be updated based on flatness
            viewport.style.transition = 'border-color 0.3s ease';

            const status = document.createElement('div');
            status.className = 'alignment-status';
            status.id = `status-${stageIndex}`;
            viewport.appendChild(status);
            const modelHeightLabel = document.createElement('div');
            modelHeightLabel.className = 'model-height-label';
            modelHeightLabel.id = `model-height-label-${modelId}`;
            let modelHeightText;
            if (scaleMode === '28mm') {
                const modelHeightMM = monsterData.originalHeight;
                const modelHeightFeetInches = mm28mmToFeetInches(modelHeightMM);
                modelHeightText = `${formatFeetInches(modelHeightFeetInches.feet, modelHeightFeetInches.inches)} (${modelHeightMM.toFixed(1)}mm)`;
            } else {
                const modelMaxDimMM = monsterData.originalMaxDimension;
                const modelMaxDimInches = mmToInches(modelMaxDimMM);
                modelHeightText = `${formatInches(modelMaxDimInches)} longest (${modelMaxDimMM.toFixed(1)}mm)`;
            }
            modelHeightLabel.textContent = modelHeightText;
            viewport.appendChild(modelHeightLabel);

            // Add canvas overlay controls (cut mode controls in top-left, download in bottom-right)
            const canvasOverlay = document.createElement('div');
            canvasOverlay.style.position = 'absolute';
            canvasOverlay.style.top = '0';
            canvasOverlay.style.left = '0';
            canvasOverlay.style.right = '0';
            canvasOverlay.style.bottom = '0';
            canvasOverlay.style.pointerEvents = 'none';
            canvasOverlay.style.zIndex = '10';

            // Top-left: Cut mode checkbox and +/- controls
            const topLeftControls = document.createElement('div');
            topLeftControls.style.position = 'absolute';
            topLeftControls.style.top = '10px';
            topLeftControls.style.left = '10px';
            topLeftControls.style.display = 'flex';
            topLeftControls.style.flexDirection = 'column';
            topLeftControls.style.gap = '5px';
            topLeftControls.style.pointerEvents = 'auto';

            // Cut Mode Checkbox
            const cutModeCheckboxDiv = document.createElement('div');
            cutModeCheckboxDiv.style.display = 'flex';
            cutModeCheckboxDiv.style.alignItems = 'center';
            cutModeCheckboxDiv.style.gap = '5px';
            cutModeCheckboxDiv.style.backgroundColor = 'rgba(42, 42, 42, 0.9)';
            cutModeCheckboxDiv.style.padding = '5px 8px';
            cutModeCheckboxDiv.style.borderRadius = '5px';
            cutModeCheckboxDiv.style.border = '2px solid #FF9800';

            const cutModeCheckbox = document.createElement('input');
            cutModeCheckbox.type = 'checkbox';
            cutModeCheckbox.id = `cut-mode-${modelId}`;
            cutModeCheckbox.style.width = '18px';
            cutModeCheckbox.style.height = '18px';
            cutModeCheckbox.style.cursor = 'pointer';
            cutModeCheckbox.addEventListener('change', (e) => {
                const stageIndex = models.get(modelId).stageIndex;
                const stage = stages[stageIndex];
                if (stage) {
                    stage.toggleCutMode(e.target.checked);
                    // Show/hide cut height adjuster
                    const cutHeightControls = document.getElementById(`cut-height-overlay-${modelId}`);
                    if (cutHeightControls) {
                        cutHeightControls.style.display = e.target.checked ? 'flex' : 'none';
                    }
                    // Show/hide cut action buttons (Apply Cut & Undo)
                    const cutButtonsControls = document.getElementById(`cut-buttons-overlay-${modelId}`);
                    if (cutButtonsControls) {
                        cutButtonsControls.style.display = e.target.checked ? 'flex' : 'none';
                    }
                }
            });
            cutModeCheckboxDiv.appendChild(cutModeCheckbox);

            const cutModeLabel = document.createElement('label');
            cutModeLabel.setAttribute('for', `cut-mode-${modelId}`);
            cutModeLabel.textContent = 'Cut Mode';
            cutModeLabel.style.color = '#FF9800';
            cutModeLabel.style.fontWeight = 'bold';
            cutModeLabel.style.fontSize = '12px';
            cutModeLabel.style.cursor = 'pointer';
            cutModeLabel.style.userSelect = 'none';
            cutModeCheckboxDiv.appendChild(cutModeLabel);
            topLeftControls.appendChild(cutModeCheckboxDiv);

            // Cut Height Adjuster (+/- buttons)
            const cutHeightOverlay = document.createElement('div');
            cutHeightOverlay.id = `cut-height-overlay-${modelId}`;
            cutHeightOverlay.style.display = 'none';
            cutHeightOverlay.style.flexDirection = 'row';
            cutHeightOverlay.style.alignItems = 'center';
            cutHeightOverlay.style.gap = '5px';
            cutHeightOverlay.style.backgroundColor = 'rgba(42, 42, 42, 0.9)';
            cutHeightOverlay.style.padding = '5px';
            cutHeightOverlay.style.borderRadius = '5px';
            cutHeightOverlay.style.border = '2px solid #FF9800';

            const cutHeightDownBtn = document.createElement('button');
            cutHeightDownBtn.textContent = '‚àí';
            cutHeightDownBtn.style.padding = '5px 10px';
            cutHeightDownBtn.style.backgroundColor = '#FF9800';
            cutHeightDownBtn.style.color = 'white';
            cutHeightDownBtn.style.border = 'none';
            cutHeightDownBtn.style.borderRadius = '3px';
            cutHeightDownBtn.style.cursor = 'pointer';
            cutHeightDownBtn.style.fontWeight = 'bold';
            cutHeightDownBtn.onclick = () => {
                const stageIndex = models.get(modelId).stageIndex;
                const stage = stages[stageIndex];
                if (stage) {
                    stage.cutHeight = Math.max(0.1, stage.cutHeight - 0.1);
                    stage.updateCutCubeHeight(stage.cutHeight);
                    const valueSpan = document.getElementById(`cut-height-value-overlay-${modelId}`);
                    if (valueSpan) {
                        valueSpan.textContent = `${stage.cutHeight.toFixed(1)}mm`;
                    }
                }
            };
            cutHeightOverlay.appendChild(cutHeightDownBtn);

            const cutHeightValueOverlay = document.createElement('span');
            cutHeightValueOverlay.id = `cut-height-value-overlay-${modelId}`;
            cutHeightValueOverlay.textContent = '0.1mm';
            cutHeightValueOverlay.style.color = '#fff';
            cutHeightValueOverlay.style.fontSize = '12px';
            cutHeightValueOverlay.style.minWidth = '45px';
            cutHeightValueOverlay.style.textAlign = 'center';
            cutHeightValueOverlay.style.fontWeight = 'bold';
            cutHeightOverlay.appendChild(cutHeightValueOverlay);

            const cutHeightUpBtn = document.createElement('button');
            cutHeightUpBtn.textContent = '+';
            cutHeightUpBtn.style.padding = '5px 10px';
            cutHeightUpBtn.style.backgroundColor = '#FF9800';
            cutHeightUpBtn.style.color = 'white';
            cutHeightUpBtn.style.border = 'none';
            cutHeightUpBtn.style.borderRadius = '3px';
            cutHeightUpBtn.style.cursor = 'pointer';
            cutHeightUpBtn.style.fontWeight = 'bold';
            cutHeightUpBtn.onclick = () => {
                const stageIndex = models.get(modelId).stageIndex;
                const stage = stages[stageIndex];
                if (stage) {
                    stage.cutHeight = Math.min(50, stage.cutHeight + 0.1);
                    stage.updateCutCubeHeight(stage.cutHeight);
                    const valueSpan = document.getElementById(`cut-height-value-overlay-${modelId}`);
                    if (valueSpan) {
                        valueSpan.textContent = `${stage.cutHeight.toFixed(1)}mm`;
                    }
                }
            };
            cutHeightOverlay.appendChild(cutHeightUpBtn);
            topLeftControls.appendChild(cutHeightOverlay);
            canvasOverlay.appendChild(topLeftControls);

            // Bottom-left: Apply Cut and Undo Buttons (hidden by default, shown when cut mode is enabled)
            const bottomLeftControls = document.createElement('div');
            bottomLeftControls.style.position = 'absolute';
            bottomLeftControls.style.bottom = '10px';
            bottomLeftControls.style.left = '10px';
            bottomLeftControls.style.display = 'flex';
            bottomLeftControls.style.flexDirection = 'column';
            bottomLeftControls.style.gap = '5px';
            bottomLeftControls.style.pointerEvents = 'auto';

            const cutButtonsOverlay = document.createElement('div');
            cutButtonsOverlay.id = `cut-buttons-overlay-${modelId}`;
            cutButtonsOverlay.style.display = 'none'; // Hidden by default, shown when cut mode is enabled
            cutButtonsOverlay.style.flexDirection = 'column';
            cutButtonsOverlay.style.gap = '5px';

            const cutButton = document.createElement('button');
            cutButton.id = `cut-button-${modelId}`;
            cutButton.textContent = '‚úÇÔ∏è Apply Cut';
            cutButton.style.padding = '8px';
            cutButton.style.backgroundColor = '#FF9800';
            cutButton.style.color = 'white';
            cutButton.style.border = 'none';
            cutButton.style.borderRadius = '5px';
            cutButton.style.cursor = 'pointer';
            cutButton.style.fontWeight = 'bold';
            cutButton.style.fontSize = '12px';
            cutButton.onclick = () => applyCutToModel(modelId);
            cutButtonsOverlay.appendChild(cutButton);

            const undoButton = document.createElement('button');
            undoButton.id = `undo-cut-${modelId}`;
            undoButton.textContent = '‚Ü©Ô∏è Undo';
            undoButton.style.padding = '8px';
            undoButton.style.backgroundColor = '#757575';
            undoButton.style.color = 'white';
            undoButton.style.border = 'none';
            undoButton.style.borderRadius = '5px';
            undoButton.style.cursor = 'pointer';
            undoButton.style.fontWeight = 'bold';
            undoButton.style.fontSize = '12px';
            undoButton.disabled = true;
            undoButton.style.opacity = '0.5';
            undoButton.onclick = () => undoCut(modelId);
            cutButtonsOverlay.appendChild(undoButton);

            bottomLeftControls.appendChild(cutButtonsOverlay);
            canvasOverlay.appendChild(bottomLeftControls);

            // ===========================
            // Top-right: Zoom and Height Controls
            // ===========================
            const topRightControls = document.createElement('div');
            topRightControls.style.position = 'absolute';
            topRightControls.style.top = '10px';
            topRightControls.style.right = '10px';
            topRightControls.style.display = 'flex';
            topRightControls.style.flexDirection = 'column';
            topRightControls.style.gap = '5px';
            topRightControls.style.pointerEvents = 'auto';

            // Zoom Controls (+/- buttons)
            const zoomControlsDiv = document.createElement('div');
            zoomControlsDiv.style.display = 'flex';
            zoomControlsDiv.style.alignItems = 'center';
            zoomControlsDiv.style.gap = '5px';
            zoomControlsDiv.style.backgroundColor = 'rgba(42, 42, 42, 0.9)';
            zoomControlsDiv.style.padding = '5px';
            zoomControlsDiv.style.borderRadius = '5px';
            zoomControlsDiv.style.border = '2px solid #2196F3';

            const zoomOutBtn = document.createElement('button');
            zoomOutBtn.textContent = '‚àí';
            zoomOutBtn.style.padding = '5px 12px';
            zoomOutBtn.style.backgroundColor = '#2196F3';
            zoomOutBtn.style.color = 'white';
            zoomOutBtn.style.border = 'none';
            zoomOutBtn.style.borderRadius = '3px';
            zoomOutBtn.style.cursor = 'pointer';
            zoomOutBtn.style.fontWeight = 'bold';
            zoomOutBtn.style.fontSize = '16px';
            zoomOutBtn.onclick = () => {
                stage.zoomLevel = Math.max(0.1, stage.zoomLevel - 0.3);
                stage.updateCamera();
            };
            zoomControlsDiv.appendChild(zoomOutBtn);

            const zoomLabel = document.createElement('span');
            zoomLabel.textContent = 'Zoom';
            zoomLabel.style.color = '#2196F3';
            zoomLabel.style.fontWeight = 'bold';
            zoomLabel.style.fontSize = '11px';
            zoomLabel.style.minWidth = '35px';
            zoomLabel.style.textAlign = 'center';
            zoomControlsDiv.appendChild(zoomLabel);

            const zoomInBtn = document.createElement('button');
            zoomInBtn.textContent = '+';
            zoomInBtn.style.padding = '5px 12px';
            zoomInBtn.style.backgroundColor = '#2196F3';
            zoomInBtn.style.color = 'white';
            zoomInBtn.style.border = 'none';
            zoomInBtn.style.borderRadius = '3px';
            zoomInBtn.style.cursor = 'pointer';
            zoomInBtn.style.fontWeight = 'bold';
            zoomInBtn.style.fontSize = '16px';
            zoomInBtn.onclick = () => {
                stage.zoomLevel = Math.min(10, stage.zoomLevel + 0.3);
                stage.updateCamera();
            };
            zoomControlsDiv.appendChild(zoomInBtn);
            topRightControls.appendChild(zoomControlsDiv);

            // Height Adjust Controls
            const heightControlsDiv = document.createElement('div');
            heightControlsDiv.id = `height-controls-overlay-${modelId}`;
            heightControlsDiv.style.display = 'flex';
            heightControlsDiv.style.flexDirection = 'column';
            heightControlsDiv.style.gap = '3px';
            heightControlsDiv.style.backgroundColor = 'rgba(42, 42, 42, 0.9)';
            heightControlsDiv.style.padding = '6px';
            heightControlsDiv.style.borderRadius = '5px';
            heightControlsDiv.style.border = '2px solid #4CAF50';
            heightControlsDiv.style.minWidth = '120px';

            if (scaleMode === '28mm') {
                const { feet, inches } = mm28mmToFeetInches(monsterData.originalHeight);

                // Height label
                const heightTitleLabel = document.createElement('div');
                heightTitleLabel.textContent = 'Height';
                heightTitleLabel.style.color = '#4CAF50';
                heightTitleLabel.style.fontWeight = 'bold';
                heightTitleLabel.style.fontSize = '11px';
                heightTitleLabel.style.textAlign = 'center';
                heightTitleLabel.style.marginBottom = '3px';
                heightControlsDiv.appendChild(heightTitleLabel);

                // Horizontal layout for Feet and Inches controls
                const heightRow = document.createElement('div');
                heightRow.style.display = 'flex';
                heightRow.style.alignItems = 'center';
                heightRow.style.gap = '5px';
                heightRow.style.justifyContent = 'center';

                // Feet input
                const feetInput = document.createElement('input');
                feetInput.type = 'number';
                feetInput.id = `feet-${modelId}`;
                feetInput.value = Math.floor(feet);
                feetInput.min = 0;
                feetInput.max = 100;
                feetInput.style.width = '35px';
                feetInput.style.padding = '3px';
                feetInput.style.backgroundColor = '#1a1a1a';
                feetInput.style.color = 'white';
                feetInput.style.border = '1px solid #4CAF50';
                feetInput.style.borderRadius = '3px';
                feetInput.style.textAlign = 'center';
                feetInput.style.fontSize = '12px';
                feetInput.addEventListener('input', () => updateModelFromInputs(modelId));
                heightRow.appendChild(feetInput);

                const feetLabel = document.createElement('span');
                feetLabel.textContent = "'";
                feetLabel.style.color = '#aaa';
                feetLabel.style.fontSize = '14px';
                feetLabel.style.fontWeight = 'bold';
                heightRow.appendChild(feetLabel);

                // Feet +/- buttons container
                const feetBtnsContainer = document.createElement('div');
                feetBtnsContainer.style.display = 'flex';
                feetBtnsContainer.style.flexDirection = 'column';
                feetBtnsContainer.style.gap = '1px';

                const feetUpBtn = document.createElement('button');
                feetUpBtn.textContent = '+';
                feetUpBtn.style.padding = '1px 5px';
                feetUpBtn.style.backgroundColor = '#4CAF50';
                feetUpBtn.style.color = 'white';
                feetUpBtn.style.border = 'none';
                feetUpBtn.style.borderRadius = '2px';
                feetUpBtn.style.cursor = 'pointer';
                feetUpBtn.style.fontSize = '10px';
                feetUpBtn.style.lineHeight = '1';
                feetUpBtn.onclick = () => adjustHeight(modelId, 'feet', 1);
                feetBtnsContainer.appendChild(feetUpBtn);

                const feetDownBtn = document.createElement('button');
                feetDownBtn.textContent = '-';
                feetDownBtn.style.padding = '1px 5px';
                feetDownBtn.style.backgroundColor = '#4CAF50';
                feetDownBtn.style.color = 'white';
                feetDownBtn.style.border = 'none';
                feetDownBtn.style.borderRadius = '2px';
                feetDownBtn.style.cursor = 'pointer';
                feetDownBtn.style.fontSize = '10px';
                feetDownBtn.style.lineHeight = '1';
                feetDownBtn.onclick = () => adjustHeight(modelId, 'feet', -1);
                feetBtnsContainer.appendChild(feetDownBtn);

                heightRow.appendChild(feetBtnsContainer);

                // Inches input
                const inchInput = document.createElement('input');
                inchInput.type = 'number';
                inchInput.id = `inches-${modelId}`;
                inchInput.value = Math.round(inches);
                inchInput.min = 0;
                inchInput.max = 11;
                inchInput.style.width = '35px';
                inchInput.style.padding = '3px';
                inchInput.style.backgroundColor = '#1a1a1a';
                inchInput.style.color = 'white';
                inchInput.style.border = '1px solid #4CAF50';
                inchInput.style.borderRadius = '3px';
                inchInput.style.textAlign = 'center';
                inchInput.style.fontSize = '12px';
                inchInput.addEventListener('input', () => updateModelFromInputs(modelId));
                heightRow.appendChild(inchInput);

                const inchLabel = document.createElement('span');
                inchLabel.textContent = '"';
                inchLabel.style.color = '#aaa';
                inchLabel.style.fontSize = '14px';
                inchLabel.style.fontWeight = 'bold';
                heightRow.appendChild(inchLabel);

                // Inches +/- buttons container
                const inchBtnsContainer = document.createElement('div');
                inchBtnsContainer.style.display = 'flex';
                inchBtnsContainer.style.flexDirection = 'column';
                inchBtnsContainer.style.gap = '1px';

                const inchUpBtn = document.createElement('button');
                inchUpBtn.textContent = '+';
                inchUpBtn.style.padding = '1px 5px';
                inchUpBtn.style.backgroundColor = '#4CAF50';
                inchUpBtn.style.color = 'white';
                inchUpBtn.style.border = 'none';
                inchUpBtn.style.borderRadius = '2px';
                inchUpBtn.style.cursor = 'pointer';
                inchUpBtn.style.fontSize = '10px';
                inchUpBtn.style.lineHeight = '1';
                inchUpBtn.onclick = () => adjustHeight(modelId, 'inches', 1);
                inchBtnsContainer.appendChild(inchUpBtn);

                const inchDownBtn = document.createElement('button');
                inchDownBtn.textContent = '-';
                inchDownBtn.style.padding = '1px 5px';
                inchDownBtn.style.backgroundColor = '#4CAF50';
                inchDownBtn.style.color = 'white';
                inchDownBtn.style.border = 'none';
                inchDownBtn.style.borderRadius = '2px';
                inchDownBtn.style.cursor = 'pointer';
                inchDownBtn.style.fontSize = '10px';
                inchDownBtn.style.lineHeight = '1';
                inchDownBtn.onclick = () => adjustHeight(modelId, 'inches', -1);
                inchBtnsContainer.appendChild(inchDownBtn);

                heightRow.appendChild(inchBtnsContainer);

                heightControlsDiv.appendChild(heightRow);

                // MM display
                const mmDisplay = document.createElement('div');
                mmDisplay.id = `mm-display-${modelId}`;
                mmDisplay.style.color = '#4CAF50';
                mmDisplay.style.fontSize = '10px';
                mmDisplay.style.textAlign = 'center';
                mmDisplay.style.marginTop = '3px';
                mmDisplay.style.fontWeight = 'bold';
                const currentMM = feetInchesToMM28mm(feet, inches);
                mmDisplay.textContent = `(${currentMM.toFixed(1)}mm)`;
                heightControlsDiv.appendChild(mmDisplay);
            } else {
                // For non-28mm modes (100mm cute, planter, etc.)
                const inches = mmToInches(monsterData.originalMaxDimension);

                const heightTitleLabel = document.createElement('div');
                heightTitleLabel.textContent = 'Size';
                heightTitleLabel.style.color = '#4CAF50';
                heightTitleLabel.style.fontWeight = 'bold';
                heightTitleLabel.style.fontSize = '11px';
                heightTitleLabel.style.textAlign = 'center';
                heightTitleLabel.style.marginBottom = '3px';
                heightControlsDiv.appendChild(heightTitleLabel);

                const inchRow = document.createElement('div');
                inchRow.style.display = 'flex';
                inchRow.style.alignItems = 'center';
                inchRow.style.gap = '3px';
                inchRow.style.justifyContent = 'center';

                const inchDownBtn = document.createElement('button');
                inchDownBtn.textContent = '‚ñº';
                inchDownBtn.style.padding = '2px 6px';
                inchDownBtn.style.backgroundColor = '#4CAF50';
                inchDownBtn.style.color = 'white';
                inchDownBtn.style.border = 'none';
                inchDownBtn.style.borderRadius = '3px';
                inchDownBtn.style.cursor = 'pointer';
                inchDownBtn.style.fontSize = '10px';
                inchDownBtn.onclick = () => adjustHeightInches(modelId, -0.5);
                inchRow.appendChild(inchDownBtn);

                const inchInput = document.createElement('input');
                inchInput.type = 'number';
                inchInput.id = `inches-${modelId}`;
                inchInput.value = inches.toFixed(1);
                inchInput.min = 0;
                inchInput.step = 0.1;
                inchInput.style.width = '45px';
                inchInput.style.padding = '3px';
                inchInput.style.backgroundColor = '#1a1a1a';
                inchInput.style.color = 'white';
                inchInput.style.border = '1px solid #4CAF50';
                inchInput.style.borderRadius = '3px';
                inchInput.style.textAlign = 'center';
                inchInput.style.fontSize = '12px';
                inchInput.addEventListener('input', () => updateModelFromInputsRegular(modelId));
                inchRow.appendChild(inchInput);

                const inchLabel = document.createElement('span');
                inchLabel.textContent = '"';
                inchLabel.style.color = '#aaa';
                inchLabel.style.fontSize = '12px';
                inchLabel.style.fontWeight = 'bold';
                inchRow.appendChild(inchLabel);

                const inchUpBtn = document.createElement('button');
                inchUpBtn.textContent = '‚ñ≤';
                inchUpBtn.style.padding = '2px 6px';
                inchUpBtn.style.backgroundColor = '#4CAF50';
                inchUpBtn.style.color = 'white';
                inchUpBtn.style.border = 'none';
                inchUpBtn.style.borderRadius = '3px';
                inchUpBtn.style.cursor = 'pointer';
                inchUpBtn.style.fontSize = '10px';
                inchUpBtn.onclick = () => adjustHeightInches(modelId, 0.5);
                inchRow.appendChild(inchUpBtn);

                heightControlsDiv.appendChild(inchRow);

                const mmDisplay = document.createElement('div');
                mmDisplay.id = `mm-display-${modelId}`;
                mmDisplay.style.color = '#4CAF50';
                mmDisplay.style.fontSize = '10px';
                mmDisplay.style.textAlign = 'center';
                mmDisplay.style.marginTop = '3px';
                mmDisplay.style.fontWeight = 'bold';
                mmDisplay.textContent = `(${monsterData.originalMaxDimension.toFixed(1)}mm)`;
                heightControlsDiv.appendChild(mmDisplay);
            }

            // Don't add height controls to topRightControls - they're now outside viewport
            canvasOverlay.appendChild(topRightControls);

            // Add height controls to the wrapper OUTSIDE the viewport
            heightControlsWrapper.appendChild(heightControlsDiv);

            // Bottom-right: Download button with descriptive text
            const downloadBtn = document.createElement('button');
            downloadBtn.id = `download-all-${modelId}`;
            downloadBtn.innerHTML = 'üíæ Download<br>STL, PNG, JPG';
            downloadBtn.title = 'Download all files: STL model, transparent PNG render, and technical JPG render';
            downloadBtn.style.position = 'absolute';
            downloadBtn.style.bottom = '10px';
            downloadBtn.style.right = '10px';
            downloadBtn.style.padding = '8px 10px';
            downloadBtn.style.backgroundColor = 'rgba(76, 175, 80, 0.9)';
            downloadBtn.style.color = 'white';
            downloadBtn.style.border = 'none';
            downloadBtn.style.borderRadius = '5px';
            downloadBtn.style.cursor = 'pointer';
            downloadBtn.style.fontWeight = 'bold';
            downloadBtn.style.fontSize = '11px';
            downloadBtn.style.lineHeight = '1.3';
            downloadBtn.style.textAlign = 'center';
            downloadBtn.style.pointerEvents = 'auto';
            downloadBtn.onclick = () => downloadModelAndScreenshot(modelId);
            canvasOverlay.appendChild(downloadBtn);

            viewport.appendChild(canvasOverlay);
            card.appendChild(viewport);

            // Flatness status displayed BELOW the canvas
            const flatnessStatusDiv = document.createElement('div');
            flatnessStatusDiv.className = 'flatness-status';
            flatnessStatusDiv.id = `flatness-${modelId}`;
            flatnessStatusDiv.style.marginTop = '10px';
            flatnessStatusDiv.textContent = '‚öôÔ∏è Ready for Cut';
            card.appendChild(flatnessStatusDiv);

            // Hidden checkbox for remove floating parts (defaults to false)
            // This controls whether floating parts are removed during cut operation
            const removeFloatingCheckbox = document.createElement('input');
            removeFloatingCheckbox.type = 'checkbox';
            removeFloatingCheckbox.id = `remove-floating-${modelId}`;
            removeFloatingCheckbox.checked = false; // Default to false - don't remove floating parts on cut
            removeFloatingCheckbox.style.display = 'none'; // Hidden from user
            card.appendChild(removeFloatingCheckbox);

            // Y-AXIS ROTATION (GREEN) - Turntable/Floor Rotation - MOVED TO TOP
            const yRotationControls = document.createElement('div');
            yRotationControls.className = 'rotation-controls y-axis';
            const yRotationLabel = document.createElement('label');
            yRotationLabel.className = 'rotation-label y-axis';
            yRotationLabel.id = `y-label-${modelId}`;
            yRotationLabel.textContent = `Y-Axis Rotation (Turntable): 125¬∞`;
            yRotationControls.appendChild(yRotationLabel);
            const yRotationSlider = document.createElement('input');
            yRotationSlider.type = 'range';
            yRotationSlider.className = 'rotation-slider y-axis';
            yRotationSlider.id = `y-rotation-${modelId}`;
            yRotationSlider.min = -180;
            yRotationSlider.max = 180;
            yRotationSlider.value = 125;
            yRotationSlider.addEventListener('input', (e) => {
                const degrees = parseFloat(e.target.value);
                document.getElementById(`y-label-${modelId}`).textContent = `Y-Axis Rotation (Turntable): ${degrees}¬∞`;
                updateModelRotation(modelId, 'y', degrees);
            });
            yRotationSlider.addEventListener('change', () => {
                bakeRotation(modelId); // Bake rotation on slider release
            });
            yRotationControls.appendChild(yRotationSlider);
            card.appendChild(yRotationControls);

            // X-AXIS and Z-AXIS ROTATION (side by side in same row)
            const xzRotationRow = document.createElement('div');
            xzRotationRow.style.display = 'flex';
            xzRotationRow.style.gap = '5px';
            xzRotationRow.style.marginTop = '5px';

            // X-AXIS ROTATION (RED) - Pitch (forward/backward tilt)
            const xRotationControls = document.createElement('div');
            xRotationControls.className = 'rotation-controls x-axis';
            xRotationControls.style.flex = '1';
            const xRotationLabel = document.createElement('label');
            xRotationLabel.className = 'rotation-label x-axis';
            xRotationLabel.id = `x-label-${modelId}`;
            xRotationLabel.textContent = `X-Axis (Pitch): 0¬∞`;
            xRotationControls.appendChild(xRotationLabel);
            const xRotationSlider = document.createElement('input');
            xRotationSlider.type = 'range';
            xRotationSlider.className = 'rotation-slider x-axis';
            xRotationSlider.id = `x-rotation-${modelId}`;
            xRotationSlider.min = -180;
            xRotationSlider.max = 180;
            xRotationSlider.value = 0;
            xRotationSlider.addEventListener('input', (e) => {
                const degrees = parseFloat(e.target.value);
                document.getElementById(`x-label-${modelId}`).textContent = `X-Axis (Pitch): ${degrees}¬∞`;
                updateModelRotation(modelId, 'x', degrees);
            });
            xRotationSlider.addEventListener('change', () => {
                bakeRotation(modelId); // Bake rotation on slider release
            });
            xRotationControls.appendChild(xRotationSlider);
            xzRotationRow.appendChild(xRotationControls);

            // Z-AXIS ROTATION (BLUE) - Roll (side tilt)
            const zRotationControls = document.createElement('div');
            zRotationControls.className = 'rotation-controls z-axis';
            zRotationControls.style.flex = '1';
            const zRotationLabel = document.createElement('label');
            zRotationLabel.className = 'rotation-label z-axis';
            zRotationLabel.id = `z-label-${modelId}`;
            zRotationLabel.textContent = `Z-Axis (Roll): 0¬∞`;
            zRotationControls.appendChild(zRotationLabel);
            const zRotationSlider = document.createElement('input');
            zRotationSlider.type = 'range';
            zRotationSlider.className = 'rotation-slider z-axis';
            zRotationSlider.id = `z-rotation-${modelId}`;
            zRotationSlider.min = -180;
            zRotationSlider.max = 180;
            zRotationSlider.value = 0;
            zRotationSlider.addEventListener('input', (e) => {
                const degrees = parseFloat(e.target.value);
                document.getElementById(`z-label-${modelId}`).textContent = `Z-Axis (Roll): ${degrees}¬∞`;
                updateModelRotation(modelId, 'z', degrees);
            });
            zRotationSlider.addEventListener('change', () => {
                bakeRotation(modelId); // Bake rotation on slider release
            });
            zRotationControls.appendChild(zRotationSlider);
            xzRotationRow.appendChild(zRotationControls);

            card.appendChild(xzRotationRow);

            document.getElementById('stages-container').appendChild(card);
            // Initialize stage and add model
            stage.init(viewport);
            stage.updateViewport = function() {
                if (!this.container) return;
                const width = this.container.clientWidth || 350;
                const height = width;
                this.renderer.setSize(width, height);
                this.camera.updateProjectionMatrix();
                this.render();
            };
            const clonedMesh = monsterData.mesh.clone();
            if (monsterData.mesh.material.isShaderMaterial || monsterData.mesh.material.isMeshPhongMaterial) {
                clonedMesh.material = monsterData.mesh.material.clone();
            } else {
                clonedMesh.material = monsterData.mesh.material.clone();
            }
            let initialScale = 1;
            if (targetHeightMM !== null && targetHeightMM > 0) {
                if (scaleMode === '28mm') {
                    initialScale = targetHeightMM / monsterData.originalHeight;
                } else {
                    initialScale = targetHeightMM / monsterData.originalMaxDimension;
                }
            }
            models.set(modelId, {
                mesh: clonedMesh,
                originalGeometry: monsterData.geometry.clone().rotateX(Math.PI / 2),
                filename: monsterData.filename,
                scale: initialScale,
                rotationX: 0,
                rotationY: 125,
                rotationZ: 0,
                baseModelRotation: new THREE.Quaternion(),
                baseBoundingBoxRotation: new THREE.Quaternion(),
                stageIndex: stageIndex,
                originalHeight: monsterData.originalHeight,
                originalMaxDimension: monsterData.originalMaxDimension,
                scaleMode: scaleMode
            });
            if (initialScale !== 1) {
                clonedMesh.scale.set(initialScale, initialScale, initialScale);
                clonedMesh.updateMatrixWorld(true);
            }
            // Initialize rotation to identity (no rotation)
            clonedMesh.rotation.x = 0;
            clonedMesh.rotation.y = 0;
            clonedMesh.rotation.z = 0;
            clonedMesh.updateMatrixWorld(true);

            // Store the base rotation as a quaternion
            const modelData = models.get(modelId);
            modelData.baseModelRotation.copy(clonedMesh.quaternion);
            modelData.baseBoundingBoxRotation.identity();
            stage.addMonster(clonedMesh, modelId);
            stages.push(stage);
            updateAllUIForModel(modelId);
            // Apply the initial 125-degree Y rotation
            updateModelRotation(modelId, 'y', 125);
        }
        function updateModelCount() {
            const count = models.size;
            const total = pendingFiles.length;
            const display = document.getElementById('modelCountDisplay');
            if (total === 0) {
                if (display) display.textContent = '0 models loaded';
            } else {
                const startIdx = (currentPage - 1) * MODELS_PER_PAGE + 1;
                const endIdx = Math.min(currentPage * MODELS_PER_PAGE, total);
                if (display) display.textContent = `${startIdx}-${endIdx} / ${total} models`;
            }
            const prevBtn = document.getElementById('prevPage');
            const nextBtn = document.getElementById('nextPage');
            if (prevBtn) prevBtn.disabled = currentPage <= 1 || total === 0;
            if (nextBtn) nextBtn.disabled = currentPage >= totalPages || total === 0;
        }
        function updateAllUIForModel(modelId) {
            const modelData = models.get(modelId);
            if (!modelData) return;
            if (modelData.scaleMode === '28mm') {
                const currentHeightMM = modelData.originalHeight * modelData.scale;
                const { feet, inches } = mm28mmToFeetInches(currentHeightMM);
                const feetInput = document.getElementById(`feet-${modelId}`);
                const inchInput = document.getElementById(`inches-${modelId}`);
                if (feetInput) feetInput.value = Math.floor(feet);
                if (inchInput) inchInput.value = Math.round(inches);
                const mmDisplay = document.getElementById(`mm-display-${modelId}`);
                if (mmDisplay) {
                    mmDisplay.textContent = `(${currentHeightMM.toFixed(1)}mm)`;
                }
                const modelHeightLabel = document.getElementById(`model-height-label-${modelId}`);
                if (modelHeightLabel) {
                    modelHeightLabel.textContent = `${formatFeetInches(feet, inches)} (${currentHeightMM.toFixed(1)}mm)`;
                }
            } else {
                const currentMaxDimensionMM = modelData.originalMaxDimension * modelData.scale;
                const inches = mmToInches(currentMaxDimensionMM);
                const inchInput = document.getElementById(`inches-${modelId}`);
                if (inchInput) inchInput.value = inches.toFixed(1);
                const mmDisplay = document.getElementById(`mm-display-${modelId}`);
                if (mmDisplay) {
                    mmDisplay.textContent = `(${currentMaxDimensionMM.toFixed(1)}mm)`;
                }
                const modelHeightLabel = document.getElementById(`model-height-label-${modelId}`);
                if (modelHeightLabel) {
                    modelHeightLabel.textContent = `${formatInches(inches)} longest (${currentMaxDimensionMM.toFixed(1)}mm)`;
                }
            }
            const stageIndex = modelData.stageIndex;
            if (stages[stageIndex]) {
                stages[stageIndex].updateHeightLabel(modelId, modelData.mesh);
                stages[stageIndex].updateModelHeightLabelPosition(modelId);
            }
        }
        window.adjustHeight = function(modelId, unit, delta) {
            const input = document.getElementById(`${unit}-${modelId}`);
            const current = parseInt(input.value) || 0;
            if (unit === 'feet') {
                input.value = Math.max(0, Math.min(100, current + delta));
            } else {
                let newVal = current + delta;
                if (newVal > 11) {
                    newVal = 0;
                    adjustHeight(modelId, 'feet', 1);
                } else if (newVal < 0) {
                    newVal = 11;
                    adjustHeight(modelId, 'feet', -1);
                }
                input.value = newVal;
            }
            updateModelFromInputs(modelId);
        };
        function updateModelFromInputs(modelId) {
            const modelData = models.get(modelId);
            if (!modelData || modelData.scaleMode !== '28mm') return;
            const feetInput = document.getElementById(`feet-${modelId}`);
            const inchesInput = document.getElementById(`inches-${modelId}`);
            if (!feetInput || !inchesInput) return;
            const feet = parseFloat(feetInput.value) || 0;
            const inches = parseFloat(inchesInput.value) || 0;
            const targetMM = feetInchesToMM28mm(feet, inches);
            const scale = targetMM / modelData.originalHeight;
            updateModelScale(modelId, scale);
        }
        window.adjustHeightInches = function(modelId, delta) {
            const input = document.getElementById(`inches-${modelId}`);
            if (!input) return;
            const current = parseFloat(input.value) || 0;
            input.value = Math.max(0, (current + delta)).toFixed(1);
            updateModelFromInputsRegular(modelId);
        };
        function updateModelFromInputsRegular(modelId) {
            const modelData = models.get(modelId);
            if (!modelData || modelData.scaleMode !== 'regular') return;
            const inchesInput = document.getElementById(`inches-${modelId}`);
            if (!inchesInput) return;
            const inches = parseFloat(inchesInput.value) || 0;
            const targetMM = inchesToMM(inches);
            const scale = targetMM / modelData.originalMaxDimension;
            updateModelScale(modelId, scale);
        }
        function updateModelScale(modelId, scale) {
            const modelData = models.get(modelId);
            if (!modelData) return;
            modelData.scale = scale;
            modelData.mesh.scale.set(scale, scale, scale);
            modelData.mesh.updateMatrixWorld(true);
            const stageIndex = modelData.stageIndex;
            if (stages[stageIndex]) {
                stages[stageIndex].alignToGround(modelData.mesh);
                stages[stageIndex].recenterCurrentView();
                stages[stageIndex].updateManPosition();
            }
            updateAllUIForModel(modelId);
            checkExportButtons();
        }
        function bakeRotation(modelId) {
            const modelData = models.get(modelId);
            if (!modelData) return;

            // Bake current rotation into base (like Stage 1's createRGBBoundingBox)
            modelData.baseModelRotation.copy(modelData.mesh.quaternion);

            // Reset baseBoundingBoxRotation to identity (keeps axes in world space)
            modelData.baseBoundingBoxRotation.identity();

            // Reset rotation values to 0
            modelData.rotationX = 0;
            modelData.rotationY = 0;
            modelData.rotationZ = 0;

            // Reset sliders to 0
            const xSlider = document.getElementById(`x-rotation-${modelId}`);
            const ySlider = document.getElementById(`y-rotation-${modelId}`);
            const zSlider = document.getElementById(`z-rotation-${modelId}`);

            if (xSlider) {
                xSlider.value = 0;
                document.getElementById(`x-label-${modelId}`).textContent = `X-Axis (Pitch): 0¬∞`;
            }
            if (ySlider) {
                ySlider.value = 0;
                document.getElementById(`y-label-${modelId}`).textContent = `Y-Axis Rotation (Turntable): 0¬∞`;
            }
            if (zSlider) {
                zSlider.value = 0;
                document.getElementById(`z-label-${modelId}`).textContent = `Z-Axis (Roll): 0¬∞`;
            }
        }

        function updateModelRotation(modelId, axis, degrees, showHelpers = false) {
            const modelData = models.get(modelId);
            if (!modelData) return;

            // Initialize base rotations if not present (for existing models)
            if (!modelData.baseModelRotation) {
                modelData.baseModelRotation = new THREE.Quaternion();
                modelData.baseModelRotation.copy(modelData.mesh.quaternion);
            }
            if (!modelData.baseBoundingBoxRotation) {
                modelData.baseBoundingBoxRotation = new THREE.Quaternion();
            }

            // Update rotation values
            if (axis === 'x') {
                modelData.rotationX = degrees;
            } else if (axis === 'y') {
                modelData.rotationY = degrees;
            } else if (axis === 'z') {
                modelData.rotationZ = degrees;
            }

            // Create a relative quaternion using Stage 1's approach
            const relativeQuat = new THREE.Quaternion();

            // Get the base axes - since baseBoundingBoxRotation is always identity (reset on bake),
            // these are ALWAYS world-space axes, giving camera-relative rotation feel
            const baseXAxis = new THREE.Vector3(1, 0, 0).applyQuaternion(modelData.baseBoundingBoxRotation);
            const baseYAxis = new THREE.Vector3(0, 1, 0).applyQuaternion(modelData.baseBoundingBoxRotation);
            const baseZAxis = new THREE.Vector3(0, 0, 1).applyQuaternion(modelData.baseBoundingBoxRotation);

            // Apply X-axis rotation
            if (modelData.rotationX && modelData.rotationX !== 0) {
                const xRotQuat = new THREE.Quaternion().setFromAxisAngle(
                    baseXAxis,
                    modelData.rotationX * Math.PI / 180
                );
                relativeQuat.premultiply(xRotQuat);
            }

            // Apply Y-axis rotation
            if (modelData.rotationY && modelData.rotationY !== 0) {
                const yRotQuat = new THREE.Quaternion().setFromAxisAngle(
                    baseYAxis,
                    modelData.rotationY * Math.PI / 180
                );
                relativeQuat.premultiply(yRotQuat);
            }

            // Apply Z-axis rotation
            if (modelData.rotationZ && modelData.rotationZ !== 0) {
                const zRotQuat = new THREE.Quaternion().setFromAxisAngle(
                    baseZAxis,
                    modelData.rotationZ * Math.PI / 180
                );
                relativeQuat.premultiply(zRotQuat);
            }

            // Apply combined rotation to the mesh
            modelData.mesh.quaternion.copy(modelData.baseModelRotation).premultiply(relativeQuat);

            modelData.mesh.updateMatrixWorld(true);

            if (stages[modelData.stageIndex]) {
                const stage = stages[modelData.stageIndex];

                // Update bounding box rotation to match mesh
                if (stage.boundingBoxHelper) {
                    stage.boundingBoxHelper.quaternion.copy(modelData.baseBoundingBoxRotation).premultiply(relativeQuat);
                }

                // Re-align to ground after rotation
                stage.alignToGround(modelData.mesh);

                // Re-check flatness
                const flatnessResult = stage.checkFlatness(modelData.mesh);
                stage.flatnessStatus.set(modelId, flatnessResult);
                stage.updateFlatnessDisplay();

                // Update height labels
                stage.updateHeightLabel(modelId, modelData.mesh);

                if (showHelpers) {
                    stage.showBoundingBoxAndAxes(modelData.mesh);
                } else {
                    stage.hideBoundingBoxAndAxes();
                }
                stage.updateManPosition();
                stage.recenterCurrentView();
                stage.render();
            }
        }
        function checkExportButtons() {
            let hasScaled = false;
            models.forEach(m => { if (Math.abs(m.scale - 1) > 0.001) hasScaled = true; });
            document.getElementById('exportEverything').disabled = !hasScaled;
        }
        function downloadModelAndScreenshot(modelId) {
            const modelData = models.get(modelId);
            if (!modelData) {
                console.error('Download failed: model data not found for', modelId);
                alert('Download failed: model data not found');
                return;
            }
            const randomSuffix = generateRandomSuffix();
            const baseName = modelData.filename.replace(/\.stl$/i, '');
            const uniqueName = `${baseName}_${randomSuffix}`;
            const stageIndex = modelData.stageIndex;
            console.log('Attempting download for model:', modelId, 'stageIndex:', stageIndex, 'stages.length:', stages.length);
            if (stages[stageIndex]) {
                const originalViewMode = stages[stageIndex].viewMode;
                stages[stageIndex].fitAllModelsAndManInView();
                setTimeout(() => {
                    const screenshotData = stages[stageIndex].takeScreenshot();
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.fillStyle = '#2a2a2a';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(img, 0, 0);
                        const jpgData = canvas.toDataURL('image/jpeg', 0.95);
                        const screenshotLink = document.createElement('a');
                        screenshotLink.href = jpgData;
                        screenshotLink.download = `${uniqueName}.jpg`;
                        document.body.appendChild(screenshotLink);
                        screenshotLink.click();
                        document.body.removeChild(screenshotLink);
                    };
                    img.src = screenshotData;
                    setTimeout(() => {
                        const transparentData = stages[stageIndex].takeTransparentTiltedScreenshot();
                        const transparentLink = document.createElement('a');
                        transparentLink.href = transparentData;
                        transparentLink.download = `${uniqueName}.png`;
                        document.body.appendChild(transparentLink);
                        transparentLink.click();
                        document.body.removeChild(transparentLink);
                        setTimeout(() => {
                            const scaledGeometry = modelData.originalGeometry.clone();
                            scaledGeometry.scale(modelData.scale, modelData.scale, modelData.scale);
                            const stlBinary = geometryToSTLBinary(scaledGeometry);
                            const blob = new Blob([stlBinary], { type: 'application/octet-stream' });
                            const url = URL.createObjectURL(blob);
                            const modelLink = document.createElement('a');
                            modelLink.href = url;
                            modelLink.download = `${uniqueName}.stl`;
                            document.body.appendChild(modelLink);
                            modelLink.click();
                            document.body.removeChild(modelLink);
                            setTimeout(() => URL.revokeObjectURL(url), 100);
                            if (originalViewMode === 'stl') {
                                stages[stageIndex].fitSTLOnlyInView();
                            } else {
                                stages[stageIndex].fitAllModelsAndManInView();
                            }
                        }, 1000);
                    }, 500);
                }, 200);
            } else {
                console.error('Download failed: stage not found. stageIndex:', stageIndex, 'stages:', stages);
                alert(`Download failed: stage not found (stageIndex: ${stageIndex}, stages.length: ${stages.length})`);
            }
        }

        // Store backup states for undo functionality
        const cutBackupStates = new Map();

        function undoCut(modelId) {
            const backup = cutBackupStates.get(modelId);
            if (!backup) {
                alert('No cut to undo!');
                return;
            }

            const modelData = models.get(modelId);
            if (!modelData) return;

            // Restore the original geometry
            const oldGeometry = modelData.mesh.geometry;
            modelData.mesh.geometry = backup.geometry.clone();
            oldGeometry.dispose();

            // Restore the original export geometry
            const oldOriginalGeo = modelData.originalGeometry;
            modelData.originalGeometry = backup.originalGeometry.clone();
            oldOriginalGeo.dispose();

            // Restore original dimensions and scale
            modelData.originalHeight = backup.originalHeight;
            modelData.originalMaxDimension = backup.originalMaxDimension;
            modelData.scale = backup.scale;
            modelData.rotationX = backup.rotationX;
            modelData.rotationY = backup.rotationY;
            modelData.rotationZ = backup.rotationZ;

            // Restore mesh transformations
            modelData.mesh.position.copy(backup.position);
            modelData.mesh.rotation.set(backup.rotationX, backup.rotationY, backup.rotationZ);
            modelData.mesh.scale.set(backup.scale, backup.scale, backup.scale);
            modelData.mesh.updateMatrixWorld(true);

            // Update rotation sliders to match restored state (fix random rotation bug)
            // Convert from radians to degrees
            const xRotationSlider = document.getElementById(`x-rotation-${modelId}`);
            const yRotationSlider = document.getElementById(`y-rotation-${modelId}`);
            const zRotationSlider = document.getElementById(`z-rotation-${modelId}`);
            const xLabel = document.getElementById(`x-label-${modelId}`);
            const yLabel = document.getElementById(`y-label-${modelId}`);
            const zLabel = document.getElementById(`z-label-${modelId}`);

            if (xRotationSlider && xLabel) {
                const xDegrees = Math.round(backup.rotationX * 180 / Math.PI);
                xRotationSlider.value = xDegrees;
                xLabel.textContent = `X-Axis: ${xDegrees}¬∞`;
            }
            if (yRotationSlider && yLabel) {
                // Note: Y slider controls Z rotation in the mesh
                const yDegrees = Math.round(backup.rotationZ * 180 / Math.PI);
                yRotationSlider.value = yDegrees;
                yLabel.textContent = `Y-Axis: ${yDegrees}¬∞`;
            }
            if (zRotationSlider && zLabel) {
                // Note: Z slider controls Y rotation in the mesh (turntable)
                const zDegrees = Math.round(backup.rotationY * 180 / Math.PI);
                zRotationSlider.value = zDegrees;
                zLabel.textContent = `Z-Axis Rotation (Turntable): ${zDegrees}¬∞`;
            }

            // Update stage
            const stageIndex = modelData.stageIndex;
            const stage = stages[stageIndex];
            if (stage) {
                stage.alignToGround(modelData.mesh);
                stage.updateHeightLabel(modelId, modelData.mesh);
                stage.recenterCurrentView();
                stage.render();
            }

            // Update UI
            updateAllUIForModel(modelId);

            // Update flatness status
            const flatnessEl = document.getElementById(`flatness-${modelId}`);
            if (flatnessEl) {
                flatnessEl.className = 'flatness-status';
                flatnessEl.textContent = '‚öôÔ∏è Ready for Cut';
            }

            // Update buttons
            const cutButton = document.getElementById(`cut-button-${modelId}`);
            if (cutButton) {
                cutButton.textContent = '‚úÇÔ∏è Apply Cut';
                cutButton.disabled = false;
                cutButton.style.backgroundColor = '#FF9800';
            }

            const undoButton = document.getElementById(`undo-cut-${modelId}`);
            if (undoButton) {
                undoButton.disabled = true;
                undoButton.style.opacity = '0.5';
            }

            // Clear the backup
            cutBackupStates.delete(modelId);

            console.log('‚úÖ Undo completed successfully!');
        }

        async function applyCutToModel(modelId) {
            const modelData = models.get(modelId);
            if (!modelData) return;
            const stageIndex = modelData.stageIndex;
            const stage = stages[stageIndex];
            if (!stage || !stage.cutCube || !stage.cutModeEnabled) {
                alert('Please enable Cut Mode first!');
                return;
            }
            const cutButton = document.getElementById(`cut-button-${modelId}`);
            if (cutButton) {
                cutButton.disabled = true;
                cutButton.textContent = '‚è≥ Cutting... Please wait';
            }
            try {
                // Save backup state before cutting
                cutBackupStates.set(modelId, {
                    geometry: modelData.mesh.geometry.clone(),
                    originalGeometry: modelData.originalGeometry.clone(),
                    originalHeight: modelData.originalHeight,
                    originalMaxDimension: modelData.originalMaxDimension,
                    scale: modelData.scale,
                    rotationX: modelData.rotationX,
                    rotationY: modelData.rotationY,
                    rotationZ: modelData.rotationZ,
                    position: modelData.mesh.position.clone()
                });
                console.log('üíæ Backup state saved for undo');

                await new Promise(resolve => setTimeout(resolve, 100));
                const mesh = modelData.mesh;
                const cutHeight = stage.groundY + stage.cutHeight;
                console.log('‚úÇÔ∏è Cutting mesh at height:', cutHeight);
                const currentRotationX = mesh.rotation.x;
                const currentRotationY = mesh.rotation.y;
                const currentRotationZ = mesh.rotation.z;
                mesh.rotation.set(0, 0, 0);
                mesh.updateMatrixWorld(true);
                const geometry = mesh.geometry.clone();
                const positions = geometry.attributes.position;
                const matrix = mesh.matrixWorld;
                geometry.applyMatrix4(matrix);
                const newVertices = [];
                const bottomContourPoints = [];
                for (let i = 0; i < positions.count; i += 3) {
                    const v0 = new THREE.Vector3().fromBufferAttribute(positions, i);
                    const v1 = new THREE.Vector3().fromBufferAttribute(positions, i + 1);
                    const v2 = new THREE.Vector3().fromBufferAttribute(positions, i + 2);
                    const above0 = v0.y > cutHeight;
                    const above1 = v1.y > cutHeight;
                    const above2 = v2.y > cutHeight;
                    const aboveCount = (above0 ? 1 : 0) + (above1 ? 1 : 0) + (above2 ? 1 : 0);
                    if (aboveCount === 3) {
                        newVertices.push(v0, v1, v2);
                    } else if (aboveCount === 0) {
                        continue;
                    } else if (aboveCount === 2) {
                        let vAbove1, vAbove2, vBelow;
                        if (!above0) {
                            vBelow = v0; vAbove1 = v1; vAbove2 = v2;
                        } else if (!above1) {
                            vBelow = v1; vAbove1 = v0; vAbove2 = v2;
                        } else {
                            vBelow = v2; vAbove1 = v0; vAbove2 = v1;
                        }
                        const t1 = (cutHeight - vBelow.y) / (vAbove1.y - vBelow.y);
                        const t2 = (cutHeight - vBelow.y) / (vAbove2.y - vBelow.y);
                        const vNew1 = new THREE.Vector3().lerpVectors(vBelow, vAbove1, t1);
                        const vNew2 = new THREE.Vector3().lerpVectors(vBelow, vAbove2, t2);
                        vNew1.y = cutHeight;
                        vNew2.y = cutHeight;
                        newVertices.push(vNew1, vAbove1, vAbove2);
                        newVertices.push(vNew1, vAbove2, vNew2);
                        bottomContourPoints.push(vNew1.clone());
                        bottomContourPoints.push(vNew2.clone());
                    } else if (aboveCount === 1) {
                        let vAbove, vBelow1, vBelow2;
                        if (above0) {
                            vAbove = v0; vBelow1 = v1; vBelow2 = v2;
                        } else if (above1) {
                            vAbove = v1; vBelow1 = v0; vBelow2 = v2;
                        } else {
                            vAbove = v2; vBelow1 = v0; vBelow2 = v1;
                        }
                        const t1 = (cutHeight - vBelow1.y) / (vAbove.y - vBelow1.y);
                        const t2 = (cutHeight - vBelow2.y) / (vAbove.y - vBelow2.y);
                        const vNew1 = new THREE.Vector3().lerpVectors(vBelow1, vAbove, t1);
                        const vNew2 = new THREE.Vector3().lerpVectors(vBelow2, vAbove, t2);
                        vNew1.y = cutHeight;
                        vNew2.y = cutHeight;
                        newVertices.push(vNew1, vAbove, vNew2);
                        bottomContourPoints.push(vNew1.clone());
                        bottomContourPoints.push(vNew2.clone());
                    }
                }
                if (bottomContourPoints.length > 0) {
                    console.log('Creating bottom cap with', bottomContourPoints.length, 'contour points');
                    const edges = [];
                    for (let i = 0; i < bottomContourPoints.length; i += 2) {
                        if (i + 1 < bottomContourPoints.length) {
                            edges.push({
                                v1: bottomContourPoints[i],
                                v2: bottomContourPoints[i + 1]
                            });
                        }
                    }
                    console.log('Created', edges.length, 'edges on cut plane');
                    const islands = [];
                    const usedEdges = new Set();
                    for (let i = 0; i < edges.length; i++) {
                        if (usedEdges.has(i)) continue;
                        const island = [];
                        const queue = [i];
                        usedEdges.add(i);
                        while (queue.length > 0) {
                            const edgeIdx = queue.shift();
                            const edge = edges[edgeIdx];
                            island.push(edge);
                            for (let j = 0; j < edges.length; j++) {
                                if (usedEdges.has(j)) continue;
                                const otherEdge = edges[j];
                                const threshold = 0.001;
                                const sharesV1V1 = edge.v1.distanceTo(otherEdge.v1) < threshold;
                                const sharesV1V2 = edge.v1.distanceTo(otherEdge.v2) < threshold;
                                const sharesV2V1 = edge.v2.distanceTo(otherEdge.v1) < threshold;
                                const sharesV2V2 = edge.v2.distanceTo(otherEdge.v2) < threshold;
                                if (sharesV1V1 || sharesV1V2 || sharesV2V1 || sharesV2V2) {
                                    queue.push(j);
                                    usedEdges.add(j);
                                }
                            }
                        }
                        if (island.length > 0) {
                            islands.push(island);
                        }
                    }
                    console.log('Found', islands.length, 'separate islands to cap');
                    islands.forEach((island, islandIdx) => {
                        const orderedLoop = [];
                        const usedEdges = new Set();
                        let currentEdge = island[0];
                        orderedLoop.push(currentEdge.v1.clone());
                        orderedLoop.push(currentEdge.v2.clone());
                        usedEdges.add(0);
                        let lastVertex = currentEdge.v2;
                        const threshold = 0.001;
                        while (usedEdges.size < island.length) {
                            let found = false;
                            for (let i = 0; i < island.length; i++) {
                                if (usedEdges.has(i)) continue;
                                const edge = island[i];
                                if (lastVertex.distanceTo(edge.v1) < threshold) {
                                    orderedLoop.push(edge.v2.clone());
                                    lastVertex = edge.v2;
                                    usedEdges.add(i);
                                    found = true;
                                    break;
                                } else if (lastVertex.distanceTo(edge.v2) < threshold) {
                                    orderedLoop.push(edge.v1.clone());
                                    lastVertex = edge.v1;
                                    usedEdges.add(i);
                                    found = true;
                                    break;
                                }
                            }
                            if (!found) break;
                        }
                        if (orderedLoop.length > 2 && orderedLoop[0].distanceTo(orderedLoop[orderedLoop.length - 1]) < threshold) {
                            orderedLoop.pop();
                        }
                        console.log('Island', islandIdx, 'has', orderedLoop.length, 'vertices in ordered loop');
                        if (orderedLoop.length >= 3) {
                            const flatCoords = [];
                            orderedLoop.forEach(v => {
                                flatCoords.push(v.x, v.z);
                            });
                            const triangleIndices = earcut(flatCoords);
                            if (triangleIndices && triangleIndices.length > 0) {
                                for (let i = 0; i < triangleIndices.length; i += 3) {
                                    const i0 = triangleIndices[i];
                                    const i1 = triangleIndices[i + 1];
                                    const i2 = triangleIndices[i + 2];
                                    newVertices.push(
                                        orderedLoop[i0].clone(),
                                        orderedLoop[i1].clone(),
                                        orderedLoop[i2].clone()
                                    );
                                }
                                console.log('‚úÖ Created', triangleIndices.length / 3, 'triangles for island', islandIdx, 'using earcut');
                            } else {
                                console.warn('‚ö†Ô∏è Earcut failed for island', islandIdx);
                            }
                        }
                    });
                }
                const resultGeometry = new THREE.BufferGeometry();
                const newPositions = new Float32Array(newVertices.length * 3);
                for (let i = 0; i < newVertices.length; i++) {
                    newPositions[i * 3] = newVertices[i].x;
                    newPositions[i * 3 + 1] = newVertices[i].y;
                    newPositions[i * 3 + 2] = newVertices[i].z;
                }
                resultGeometry.setAttribute('position', new THREE.BufferAttribute(newPositions, 3));
                resultGeometry.computeVertexNormals();
                console.log('‚úÖ Cut complete. Original vertices:', positions.count, 'New vertices:', newVertices.length);
                let finalGeometry = resultGeometry;
                // Only check the per-model hidden checkbox (not the global one)
                // The global checkbox only applies on initial model load
                const localRemoveFloating = document.getElementById(`remove-floating-${modelId}`);
                if (localRemoveFloating && localRemoveFloating.checked) {
                    console.log('üßπ Checking for floating parts after cut...');
                    finalGeometry = removeFloatingParts(resultGeometry);
                    if (finalGeometry !== resultGeometry) {
                        resultGeometry.dispose();
                    }
                }
                const oldGeometry = mesh.geometry;
                mesh.geometry = finalGeometry;
                mesh.position.set(0, 0, 0);
                mesh.rotation.set(0, 0, 0);
                mesh.scale.set(1, 1, 1);
                mesh.updateMatrixWorld(true);
                oldGeometry.dispose();
                geometry.dispose();
                stage.alignToGround(mesh);
                mesh.rotation.x = currentRotationX;
                mesh.rotation.y = currentRotationY;
                mesh.rotation.z = currentRotationZ;
                mesh.updateMatrixWorld(true);
                const exportGeo = finalGeometry.clone();
                exportGeo.rotateX(Math.PI / 2);
                const oldOriginalGeo = modelData.originalGeometry;
                modelData.originalGeometry = exportGeo;
                oldOriginalGeo.dispose();
                finalGeometry.computeBoundingBox();
                const newBox = finalGeometry.boundingBox;
                const newSize = newBox.getSize(new THREE.Vector3());
                modelData.originalHeight = newSize.y;
                modelData.originalMaxDimension = Math.max(newSize.x, newSize.y, newSize.z);
                modelData.scale = 1.0;
                const flatnessResult = stage.checkFlatness(mesh);
                stage.flatnessStatus.set(modelId, flatnessResult);
                stage.updateFlatnessDisplay();
                const flatnessEl = document.getElementById(`flatness-${modelId}`);
                if (flatnessEl) {
                    if (flatnessResult.isFlat) {
                        flatnessEl.className = 'flatness-status flat';
                        flatnessEl.textContent = '‚úì Bottom Flat (After Cut)';
                    } else {
                        flatnessEl.className = 'flatness-status not-flat';
                        flatnessEl.textContent = `‚ö† Not Flat: ${flatnessResult.reason}`;
                    }
                }
                stage.updateHeightLabel(modelId, mesh);
                updateAllUIForModel(modelId);
                stage.updateManPosition();
                stage.recenterCurrentView();
                stage.render();

                // Hide cut mode UI after successful cut
                const cutModeCheckbox = document.getElementById(`cut-mode-${modelId}`);
                if (cutModeCheckbox && cutModeCheckbox.checked) {
                    cutModeCheckbox.checked = false;
                    stage.toggleCutMode(false);

                    // Hide cut height adjuster overlay
                    const cutHeightOverlay = document.getElementById(`cut-height-overlay-${modelId}`);
                    if (cutHeightOverlay) {
                        cutHeightOverlay.style.display = 'none';
                    }

                    // Hide cut buttons overlay (Apply Cut & Undo)
                    const cutButtonsOverlay = document.getElementById(`cut-buttons-overlay-${modelId}`);
                    if (cutButtonsOverlay) {
                        cutButtonsOverlay.style.display = 'none';
                    }
                }

                // Update cut button status
                if (cutButton) {
                    cutButton.textContent = '‚úÖ Cut Applied!';
                    cutButton.style.backgroundColor = '#4CAF50';
                    setTimeout(() => {
                        cutButton.textContent = '‚úÇÔ∏è Apply Cut';
                        cutButton.disabled = false;
                        cutButton.style.backgroundColor = '#FF9800';
                    }, 3000);
                }

                // Enable undo button
                const undoButton = document.getElementById(`undo-cut-${modelId}`);
                if (undoButton) {
                    undoButton.disabled = false;
                    undoButton.style.opacity = '1';
                }

                console.log('‚úÖ Cut operation completed successfully!');
            } catch (error) {
                console.error('Error during cut operation:', error);
                alert('Error cutting model: ' + error.message);
                if (cutButton) {
                    cutButton.textContent = '‚ùå Cut Failed - Try Again';
                    cutButton.disabled = false;
                }
            }
        }
        async function exportEverything() {
            console.log('üíæ Downloading all models...');
            const toExport = Array.from(models.keys());
            if (toExport.length === 0) {
                console.log('No models to download');
                return;
            }
            for (let i = 0; i < toExport.length; i++) {
                console.log(`Downloading ${i + 1}/${toExport.length}: ${toExport[i]}`);
                downloadModelAndScreenshot(toExport[i]);
                if (i < toExport.length - 1) await new Promise(r => setTimeout(r, 1500));
            }
            console.log('‚úÖ All download requests completed');
        }
        function geometryToSTLBinary(geometry) {
            const positions = geometry.attributes.position;
            const normals = geometry.attributes.normal;
            const triangles = positions.count / 3;
            const arrayBuffer = new ArrayBuffer(84 + (triangles * 50));
            const dataView = new DataView(arrayBuffer);
            const header = 'STL Binary - 28mm Scaler';
            for (let i = 0; i < header.length; i++) {
                dataView.setUint8(i, header.charCodeAt(i));
            }
            dataView.setUint32(80, triangles, true);
            let offset = 84;
            for (let i = 0; i < triangles; i++) {
                const idx = i * 3;
                let nx, ny, nz;
                if (normals) {
                    nx = normals.getX(idx);
                    ny = normals.getY(idx);
                    nz = normals.getZ(idx);
                } else {
                    const v1 = new THREE.Vector3(
                        positions.getX(idx),
                        positions.getY(idx),
                        positions.getZ(idx)
                    );
                    const v2 = new THREE.Vector3(
                        positions.getX(idx + 1),
                        positions.getY(idx + 1),
                        positions.getZ(idx + 1)
                    );
                    const v3 = new THREE.Vector3(
                        positions.getX(idx + 2),
                        positions.getY(idx + 2),
                        positions.getZ(idx + 2)
                    );
                    const edge1 = v2.sub(v1);
                    const edge2 = v3.sub(v1);
                    const normal = edge1.cross(edge2).normalize();
                    nx = normal.x;
                    ny = normal.y;
                    nz = normal.z;
                }
                dataView.setFloat32(offset, nx, true);
                dataView.setFloat32(offset + 4, ny, true);
                dataView.setFloat32(offset + 8, nz, true);
                offset += 12;
                for (let j = 0; j < 3; j++) {
                    dataView.setFloat32(offset, positions.getX(idx + j), true);
                    dataView.setFloat32(offset + 4, positions.getY(idx + j), true);
                    dataView.setFloat32(offset + 8, positions.getZ(idx + j), true);
                    offset += 12;
                }
                dataView.setUint16(offset, 0, true);
                offset += 2;
            }
            return arrayBuffer;
        }
        document.getElementById('processNoScale').addEventListener('click', () => processWithScale(null, '28mm', 'processNoScale'));
        document.getElementById('process32mm').addEventListener('click', () => processWithScale(feetInchesToMM28mm(6, 2), '28mm', 'process32mm'));
        document.getElementById('process9ft').addEventListener('click', () => processWithScale(feetInchesToMM28mm(9, 0), '28mm', 'process9ft'));
        document.getElementById('process12ft').addEventListener('click', () => processWithScale(feetInchesToMM28mm(12, 0), '28mm', 'process12ft'));
        document.getElementById('process100mm').addEventListener('click', () => processWithScale(100, 'regular', 'process100mm'));
        document.getElementById('process300mm').addEventListener('click', () => processWithScale(290, 'regular', 'process300mm'));
        document.getElementById('clearAll').addEventListener('click', clearAll);
        document.getElementById('exportEverything').addEventListener('click', exportEverything);
        document.getElementById('prevPage').addEventListener('click', goToPreviousPage);
        document.getElementById('nextPage').addEventListener('click', goToNextPage);

        // Debug bounding box toggle
        document.getElementById('debugBoundingBox').addEventListener('change', (e) => {
            const showDebugBox = e.target.checked;
            stages.forEach((stage, stageIndex) => {
                models.forEach((modelData, modelId) => {
                    if (modelData.stageIndex === stageIndex && modelData.mesh) {
                        if (showDebugBox) {
                            stage.showBoundingBoxAndAxes(modelData.mesh, 0xFFD700);
                        } else {
                            stage.hideBoundingBoxAndAxes();
                        }
                    }
                });
            });
        });

        setupDragAndDrop();
        updateModelCount();
        const pageDisplay = document.getElementById('pageDisplay');
        if (pageDisplay) {
            pageDisplay.textContent = 'Page 1 / 1';
        }
        window.addEventListener('resize', () => {
            stages.forEach(s => {
                if (s.updateViewport) {
                    s.updateViewport();
                }
            });
        });
    </script>
</body>
</html>
