<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image SEO Title Generator - Collection Folders</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            max-width: 1400px;
        }
        
        input, textarea {
            width: 100%;
            margin: 5px 0 15px 0;
            padding: 8px;
            box-sizing: border-box;
        }
        
        .drop-zone {
            border: 2px dashed #999;
            padding: 40px;
            text-align: center;
            margin: 20px 0;
            cursor: pointer;
            background: #f9f9f9;
        }
        
        .drop-zone.dragover {
            background: #e0e0e0;
        }
        
        button {
            padding: 10px 20px;
            margin: 10px 5px;
            cursor: pointer;
        }
        
        button:hover {
            opacity: 0.8;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        button:disabled:hover {
            opacity: 0.5;
        }
        
        #pauseBtn {
            background-color: #ff9800;
            color: white;
        }
        
        #pauseBtn:hover {
            background-color: #e68900;
        }
        
        #stopBtn {
            background-color: #f44336;
            color: white;
        }
        
        #stopBtn:hover {
            background-color: #da190b;
        }
        
        #resumeBtn {
            background-color: #4CAF50;
            color: white;
        }
        
        #resumeBtn:hover {
            background-color: #45a049;
        }
        
        .control-buttons {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            align-items: center;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        th, td {
            border: 1px solid #ccc;
            padding: 10px;
            text-align: left;
        }
        
        td:nth-child(3) {
            cursor: pointer;
            position: relative;
        }
        
        td:nth-child(3):hover:not(.copied) {
            background-color: #f5f5f5;
        }
        
        tr.error-row td:nth-child(3):hover:not(.copied) {
            background-color: #ffb3b3;
        }
        
        th {
            background: #f0f0f0;
        }
        
        tr.error-row {
            background-color: #ffcccc;
        }
        
        .copied {
            background-color: #90EE90 !important;
            transition: background-color 0.3s ease;
        }
        
        tr.error-row .copied {
            background-color: #90EE90 !important;
        }
        
        tr.paused-row {
            background-color: #fff3cd;
        }
        
        .modifiers {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        
        .modifier-group {
            flex: 1;
        }
        
        .status {
            margin: 10px 0;
            padding: 10px;
        }
        
        .error {
            background: #fee;
            color: #c00;
        }
        
        .success {
            background: #efe;
            color: #060;
        }
        
        .warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffc107;
        }
        
        .paused {
            background: #fff3cd;
            color: #856404;
            border: 2px solid #ff9800;
        }
        
        .file-input {
            display: none;
        }
        
        .collection-item {
            padding: 8px 12px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        
        .collection-item:hover {
            background-color: #f0f0f0;
            border-color: #bbb;
        }
        
        .collection-title {
            font-weight: bold;
            color: #333;
        }
        
        .collection-files {
            font-size: 14px;
            color: #666;
            margin-top: 4px;
        }
        
        .optimization-note {
            background: #e8f4ff;
            border-left: 4px solid #0066cc;
            padding: 10px 15px;
            margin: 15px 0;
            font-size: 14px;
            color: #333;
        }
        
        .preview-img {
            max-width: 100px;
            max-height: 100px;
            border: 1px solid #ddd;
            cursor: zoom-in;
            display: block;
            margin: 0 auto;
        }
        
        .preview-img:hover {
            border-color: #999;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        /* Modal for full-size preview */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            cursor: zoom-out;
        }
        
        .modal-content {
            margin: auto;
            display: block;
            max-width: 80%;
            max-height: 80%;
            margin-top: 50px;
            border: 2px solid white;
        }
        
        .modal-close {
            position: absolute;
            top: 15px;
            right: 35px;
            color: #f1f1f1;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .modal-close:hover {
            color: #999;
        }
        
        .retry-indicator {
            color: #ff9800;
            font-size: 12px;
            font-style: italic;
        }
        
        td:last-child {
            text-align: center;
        }
        
        .folder-info {
            background: #fffbf0;
            border-left: 4px solid #ff9800;
            padding: 10px 15px;
            margin: 15px 0;
            font-size: 14px;
            color: #333;
        }
        
        .retry-info {
            background: #fff0f5;
            border-left: 4px solid #e91e63;
            padding: 10px 15px;
            margin: 15px 0;
            font-size: 14px;
            color: #333;
        }
    </style>
</head>
<body>
    <h1>Image SEO Title Generator - Collection Folders</h1>
    
    <div class="optimization-note">
        <strong>‚ö° Optimization Active:</strong> Images are automatically resized (longest side = 512px, aspect ratio preserved) to reduce API costs by ~90%. Unlimited auto-retry ensures no "sorry" responses - will keep trying until successful.
    </div>
    
    <div class="folder-info">
        <strong>üìÅ Folder Structure Required:</strong> Drag and drop your "CREATION MASTER FOLDER" which should contain collection folders. Each collection folder must have a "000 DOUBLE CHECKED" subfolder containing PNG files. The collection name will be automatically injected into prompts using the template below.
    </div>
    
    <div class="retry-info">
        <strong>üîÅ Auto-Retry Active:</strong> The system will automatically retry if the generated title contains: "sorry", "error", "error:", or "hoodie". It will keep trying until a clean title is generated.
        <br><strong>üßπ Auto-Clean Active:</strong> Any words from the collection name that appear in the generated SEO title will be automatically removed to prevent duplication when you append the collection name later.
    </div>
    
    <div>
        <label><strong>OpenAI API Key:</strong></label>
        <input type="password" id="apiKey" placeholder="sk-..." />
        <div style="font-size: 12px; color: #666; margin-top: 5px;">
            Ensure your API key is copied correctly without any extra spaces or special characters
        </div>
    </div>
    <div>
        <label><strong>Prepend Injection Prompt:</strong></label>
        <textarea id="prependPrompt" rows="3" style="background-color: #fffbf0; border: 2px solid #ff9800;">Generate an SEO Title for this object which belongs to our [collection name] collection. DO NOT MENTION [collection name] in the SEO title. We will auto append this text in later. So don't say it or else it's repeating. Make sure you don't ever mention [collection name] in the SEO title.</textarea>
        <div style="font-size: 12px; color: #666; margin-top: 5px;">
            Note: Any words from the collection name that appear in the generated title will be automatically removed before display.
        </div>
    </div>
    <div>
        <label><strong>System Instructions:</strong></label>
        <textarea id="systemPrompt" rows="4" placeholder="Your custom instructions (will be added after the prepend prompt)"></textarea>
    </div>
    <div>
        <label>
            <input type="checkbox" id="inheritCheckbox" checked>
            <strong>Inherit System Instructions</strong>
        </label>
    </div>
    <div>
        <label><strong>Additional Instructions:</strong></label>
        <textarea id="userPrompt" rows="3" placeholder="Additional context or requirements (will be added after the prepend prompt)"></textarea>
    </div>
    <div class="modifiers">
        <div class="modifier-group">
            <label><strong>Prefix Modifier:</strong></label>
            <input type="text" id="prefixModifier" placeholder="e.g., 'Buy ' or 'Premium '" />
        </div>
        <div class="modifier-group">
            <label><strong>Suffix Modifier:</strong></label>
            <input type="text" id="suffixModifier" placeholder="e.g., ' Online' or ' - Best Price'" />
        </div>
    </div>
    <div class="drop-zone" id="dropZone">
        <p>Drag & Drop "CREATION MASTER FOLDER" Here</p>
        <p>or click to select folder</p>
        <p style="font-size: 12px; color: #666;">The folder should contain collection folders with "000 DOUBLE CHECKED" subfolders</p>
        <input type="file" id="fileInput" class="file-input" webkitdirectory directory multiple />
    </div>
    <div id="collectionsList"></div>
    <div class="control-buttons">
        <button id="processBtn" disabled>Generate SEO Titles</button>
        <button id="pauseBtn" style="display: none;">‚è∏ Pause</button>
        <button id="resumeBtn" style="display: none;">‚ñ∂ Resume</button>
        <button id="stopBtn" style="display: none;">‚èπ Stop</button>
        <button id="copyBtn" style="display: none;">Copy Table to Clipboard</button>
    </div>
    <div id="status"></div>
    <div id="results" style="display: none;">
        <h2>Generated SEO Titles</h2>
        <p style="font-size: 14px; color: #666; margin: 10px 0;">Click any SEO title to copy it to clipboard | Click preview images to enlarge</p>
        <table id="resultsTable">
            <thead>
                <tr>
                    <th>Categories</th>
                    <th>Temp WIP Name Pending Renaming</th>
                    <th>Listing Title</th>
                    <th>Char Count</th>
                    <th>Preview Sent</th>
                </tr>
            </thead>
            <tbody id="resultsBody">
            </tbody>
        </table>
    </div>
    <!-- Modal for image preview -->
    <div id="imageModal" class="modal">
        <span class="modal-close">&times;</span>
        <img class="modal-content" id="modalImg">
    </div>
    <script>
        let processedFiles = [];
        let originalTitles = {};
        let previewImages = {};
        let processingState = 'idle'; // idle, running, paused, stopped
        let currentProcessIndex = 0;
        
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const processBtn = document.getElementById('processBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resumeBtn = document.getElementById('resumeBtn');
        const stopBtn = document.getElementById('stopBtn');
        const copyBtn = document.getElementById('copyBtn');
        const resultsSection = document.getElementById('results');
        const resultsBody = document.getElementById('resultsBody');
        const resultsTable = document.getElementById('resultsTable');
        const status = document.getElementById('status');
        const collectionsList = document.getElementById('collectionsList');
        const prefixModifier = document.getElementById('prefixModifier');
        const suffixModifier = document.getElementById('suffixModifier');
        const prependPromptField = document.getElementById('prependPrompt');
        const systemPromptField = document.getElementById('systemPrompt');
        const userPromptField = document.getElementById('userPrompt');
        const inheritCheckbox = document.getElementById('inheritCheckbox');
        const modal = document.getElementById('imageModal');
        const modalImg = document.getElementById('modalImg');
        const modalClose = document.getElementsByClassName('modal-close')[0];
        const apiKeyInput = document.getElementById('apiKey');
        
        // Clean API key on paste
        apiKeyInput.addEventListener('paste', (e) => {
            setTimeout(() => {
                // Remove any non-ASCII characters and extra spaces
                apiKeyInput.value = apiKeyInput.value.trim().replace(/[^\x00-\x7F]/g, '').replace(/\s+/g, '');
            }, 0);
        });
        
        // Clean API key on blur (when user leaves the field)
        apiKeyInput.addEventListener('blur', () => {
            apiKeyInput.value = apiKeyInput.value.trim().replace(/[^\x00-\x7F]/g, '').replace(/\s+/g, '');
        });
        
        modalClose.onclick = function() {
            modal.style.display = 'none';
        }
        
        modal.onclick = function(e) {
            if (e.target === modal) {
                modal.style.display = 'none';
            }
        }
        // Sync system instructions to additional instructions when checkbox is checked
        function syncInstructions() {
            if (inheritCheckbox.checked) {
                userPromptField.value = systemPromptField.value;
            }
        }
        // Add multiple event listeners to catch all types of input
        systemPromptField.addEventListener('input', syncInstructions);
        systemPromptField.addEventListener('paste', () => setTimeout(syncInstructions, 0));
        systemPromptField.addEventListener('change', syncInstructions);
        systemPromptField.addEventListener('keyup', syncInstructions);
        systemPromptField.addEventListener('mouseup', syncInstructions);
        // Auto-uncheck inheritance when user tries to edit Additional Instructions
        userPromptField.addEventListener('input', () => {
            if (inheritCheckbox.checked && userPromptField.value !== systemPromptField.value) {
                inheritCheckbox.checked = false;
            }
        });
        
        userPromptField.addEventListener('paste', () => {
            setTimeout(() => {
                if (inheritCheckbox.checked && userPromptField.value !== systemPromptField.value) {
                    inheritCheckbox.checked = false;
                }
            }, 0);
        });
        // Drag and drop events
        dropZone.addEventListener('click', () => fileInput.click());
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });
        
        dropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            await handleFolderDrop(e.dataTransfer.items);
        });
        
        fileInput.addEventListener('change', (e) => {
            handleFolderSelect(e.target.files);
        });
        // Modifier events
        prefixModifier.addEventListener('input', updateAllTitles);
        suffixModifier.addEventListener('input', updateAllTitles);
        // Control button events
        pauseBtn.addEventListener('click', () => {
            processingState = 'paused';
            pauseBtn.style.display = 'none';
            resumeBtn.style.display = 'inline-block';
            showStatus('Processing paused. You can now modify prompts and click Resume to continue.', 'paused');
        });
        resumeBtn.addEventListener('click', () => {
            processingState = 'running';
            pauseBtn.style.display = 'inline-block';
            resumeBtn.style.display = 'none';
            showStatus('Processing resumed...', 'warning');
            // Continue processing from where we left off
            continueProcessing();
        });
        stopBtn.addEventListener('click', () => {
            processingState = 'stopped';
            pauseBtn.style.display = 'none';
            resumeBtn.style.display = 'none';
            stopBtn.style.display = 'none';
            processBtn.disabled = false;
            processBtn.textContent = 'Generate SEO Titles';
            showStatus('Processing stopped. Click "Generate SEO Titles" to start over.', 'warning');
            copyBtn.style.display = 'inline-block';
            // Reset the index for next run
            currentProcessIndex = 0;
        });
        function naturalSort(a, b) {
            const regex = /(\d+)|(\D+)/g;
            const aParts = a.fileName.match(regex);
            const bParts = b.fileName.match(regex);
            
            for (let i = 0; i < Math.min(aParts.length, bParts.length); i++) {
                const aPart = aParts[i];
                const bPart = bParts[i];
                
                const aIsNum = /^\d+$/.test(aPart);
                const bIsNum = /^\d+$/.test(bPart);
                
                if (aIsNum && bIsNum) {
                    const diff = parseInt(aPart) - parseInt(bPart);
                    if (diff !== 0) return diff;
                } else if (aPart !== bPart) {
                    return aPart.localeCompare(bPart);
                }
            }
            
            return aParts.length - bParts.length;
        }
        
        // FIXED: Improved drag and drop handling
        async function handleFolderDrop(items) {
            processedFiles = [];
            const collections = {};
            
            const promises = [];
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                if (item.kind === 'file') {
                    const entry = item.webkitGetAsEntry();
                    if (entry && entry.isDirectory) {
                        promises.push(scanDirectory(entry, collections, ''));
                    }
                }
            }
            
            // Wait for all scanning to complete
            await Promise.all(promises);
            processFilesFromCollections(collections);
        }
        
        // FIXED: Improved directory scanning with proper entry reading
        async function scanDirectory(dirEntry, collections, path = '') {
            const reader = dirEntry.createReader();
            let allEntries = [];
            
            // Keep reading until we get all entries (readEntries may not return all at once)
            const readAllEntries = async () => {
                const entries = await new Promise((resolve, reject) => {
                    reader.readEntries(resolve, reject);
                });
                
                if (entries.length > 0) {
                    allEntries = allEntries.concat(entries);
                    await readAllEntries(); // Recursive call to get remaining entries
                }
            };
            
            await readAllEntries();
            
            for (let entry of allEntries) {
                if (entry.isDirectory) {
                    const fullPath = path ? `${path}/${entry.name}` : entry.name;
                    
                    // Check if this is a "000 DOUBLE CHECKED" folder
                    if (entry.name === '000 DOUBLE CHECKED') {
                        // Get the collection name (parent folder)
                        const pathParts = fullPath.split('/');
                        const collectionName = pathParts[pathParts.length - 2] || entry.name;
                        
                        // Read PNG files from this directory
                        const pngFiles = await readPNGFiles(entry);
                        if (pngFiles.length > 0) {
                            if (!collections[collectionName]) {
                                collections[collectionName] = [];
                            }
                            collections[collectionName].push(...pngFiles);
                        }
                    } else {
                        // Continue scanning subdirectories
                        await scanDirectory(entry, collections, fullPath);
                    }
                }
            }
        }
        
        async function readPNGFiles(dirEntry) {
            const reader = dirEntry.createReader();
            let allEntries = [];
            
            // Keep reading until we get all entries
            const readAllEntries = async () => {
                const entries = await new Promise((resolve, reject) => {
                    reader.readEntries(resolve, reject);
                });
                
                if (entries.length > 0) {
                    allEntries = allEntries.concat(entries);
                    await readAllEntries();
                }
            };
            
            await readAllEntries();
            
            const pngFiles = [];
            
            for (let entry of allEntries) {
                if (entry.isFile && entry.name.toLowerCase().endsWith('.png')) {
                    const file = await new Promise((resolve, reject) => {
                        entry.file(resolve, reject);
                    });
                    pngFiles.push(file);
                }
            }
            
            return pngFiles;
        }
        
        function handleFolderSelect(files) {
            processedFiles = [];
            const collections = {};
            
            // Process files from folder selection
            for (let file of files) {
                // Check if file is in a "000 DOUBLE CHECKED" folder and is a PNG
                if (file.webkitRelativePath && file.name.toLowerCase().endsWith('.png')) {
                    const pathParts = file.webkitRelativePath.split('/');
                    
                    // Find "000 DOUBLE CHECKED" in the path
                    const doubleCheckedIndex = pathParts.indexOf('000 DOUBLE CHECKED');
                    
                    if (doubleCheckedIndex > 0) {
                        // Get collection name (folder before "000 DOUBLE CHECKED")
                        const collectionName = pathParts[doubleCheckedIndex - 1];
                        
                        if (!collections[collectionName]) {
                            collections[collectionName] = [];
                        }
                        collections[collectionName].push(file);
                    }
                }
            }
            
            processFilesFromCollections(collections);
        }
        function processFilesFromCollections(collections) {
            processedFiles = [];
            
            // Convert collections to flat array with collection info
            for (let collectionName in collections) {
                collections[collectionName].forEach(file => {
                    processedFiles.push({
                        collectionName: collectionName,
                        fileName: file.name,
                        file: file
                    });
                });
            }
            
            // Sort files naturally
            processedFiles.sort(naturalSort);
            
            updateCollectionsDisplay(collections);
        }
        
        function updateCollectionsDisplay(collections) {
            if (Object.keys(collections).length === 0) {
                collectionsList.innerHTML = '';
                processBtn.disabled = true;
                return;
            }
            
            let totalFiles = 0;
            let html = `
                <div style="margin: 20px 0;">
                    <h3>Found Collections:</h3>
            `;
            
            for (let collectionName in collections) {
                const fileCount = collections[collectionName].length;
                totalFiles += fileCount;
                html += `
                    <div class="collection-item">
                        <div class="collection-title">üìÅ ${collectionName}</div>
                        <div class="collection-files">${fileCount} PNG file${fileCount !== 1 ? 's' : ''} found in "000 DOUBLE CHECKED"</div>
                    </div>
                `;
            }
            
            html += `
                <div style="margin-top: 15px; padding: 10px; background: #f0f0f0; border-radius: 5px;">
                    <strong>Total: ${totalFiles} PNG files across ${Object.keys(collections).length} collections</strong>
                </div>
                <button onclick="clearAllFiles()" style="margin-top: 10px; padding: 5px 10px;">Clear All</button>
                </div>
            `;
            
            collectionsList.innerHTML = html;
            processBtn.disabled = false;
        }
        
        function clearAllFiles() {
            processedFiles = [];
            collectionsList.innerHTML = '';
            processBtn.disabled = true;
            // Also clear results
            resultsSection.style.display = 'none';
            resultsBody.innerHTML = '';
            originalTitles = {};
            previewImages = {};
            copyBtn.style.display = 'none';
            pauseBtn.style.display = 'none';
            resumeBtn.style.display = 'none';
            stopBtn.style.display = 'none';
            status.textContent = '';
            status.className = '';
            processingState = 'idle';
            currentProcessIndex = 0;
        }
        
        // Make clearAllFiles globally accessible
        window.clearAllFiles = clearAllFiles;
        // Function to remove collection words from title
        function removeCollectionWordsFromTitle(title, collectionName) {
            // Split collection name into words (handle various separators)
            const collectionWords = collectionName
                .split(/[\s\-_]+/) // Split by spaces, hyphens, underscores
                .filter(word => word.length > 2) // Only consider words with more than 2 characters
                .filter(word => !/^\d+$/.test(word)) // Exclude pure numbers
                .map(word => word.toLowerCase());
            
            // Track which words were actually removed
            const removedWords = [];
            let cleanedTitle = title;
            
            collectionWords.forEach(word => {
                // Create regex to match the word as a whole word (not part of another word)
                // Escape special regex characters in the word
                const escapedWord = word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(`\\b${escapedWord}\\b`, 'gi');
                
                // Check if the word exists in the title before removing
                const matches = cleanedTitle.match(regex);
                if (matches) {
                    removedWords.push(word);
                    cleanedTitle = cleanedTitle.replace(regex, '').trim();
                }
            });
            
            // Clean up multiple spaces that might result from removing words
            cleanedTitle = cleanedTitle.replace(/\s+/g, ' ').trim();
            
            if (removedWords.length > 0) {
                console.log(`Removed words [${removedWords.join(', ')}] from title. Original: "${title}" | Cleaned: "${cleanedTitle}"`);
            }
            
            return cleanedTitle;
        }
        // Function to check if title contains invalid words
        function titleContainsInvalidWords(title) {
            const lowerTitle = title.toLowerCase();
            const invalidWords = ['sorry', 'error', 'error:', 'hoodie'];
            
            for (let word of invalidWords) {
                if (lowerTitle.includes(word)) {
                    console.log(`Title contains invalid word "${word}": ${title}`);
                    return true;
                }
            }
            return false;
        }
        processBtn.addEventListener('click', async () => {
            const apiKey = document.getElementById('apiKey').value.trim();
            
            if (!apiKey) {
                showError('Please enter your OpenAI API key');
                return;
            }
            
            // Validate API key format
            if (apiKey.length < 20) {
                showError('API key appears to be too short. Please check your OpenAI API key.');
                return;
            }
            
            // Check for non-ASCII characters in API key
            if (!/^[\x00-\x7F]*$/.test(apiKey)) {
                showError('API key contains invalid characters. Please ensure you copied it correctly without any special characters.');
                return;
            }
            
            // Check if API key starts with sk-
            if (!apiKey.startsWith('sk-')) {
                showError('API key should start with "sk-". Please check your OpenAI API key.');
                return;
            }
            
            if (processedFiles.length === 0) {
                showError('Please select a folder containing collections');
                return;
            }
            
            // Initialize processing
            processingState = 'running';
            currentProcessIndex = 0;
            processBtn.disabled = true;
            processBtn.textContent = 'Processing...';
            pauseBtn.style.display = 'inline-block';
            stopBtn.style.display = 'inline-block';
            copyBtn.style.display = 'none';
            resultsSection.style.display = 'block';
            resultsBody.innerHTML = '';
            originalTitles = {};
            previewImages = {};
            
            // Add all rows immediately
            for (let i = 0; i < processedFiles.length; i++) {
                const item = processedFiles[i];
                const row = document.createElement('tr');
                row.id = `row-${i}`;
                row.innerHTML = `
                    <td>${item.collectionName}</td>
                    <td>${item.fileName}</td>
                    <td>Pending...</td>
                    <td>-</td>
                    <td>-</td>
                `;
                resultsBody.appendChild(row);
            }
            
            // Start processing
            await processFiles();
        });
        async function processFiles() {
            const apiKey = document.getElementById('apiKey').value.trim();
            const prependPrompt = document.getElementById('prependPrompt').value;
            const baseSystemPrompt = document.getElementById('systemPrompt').value || '';
            const baseUserPrompt = document.getElementById('userPrompt').value || '';
            
            for (let i = currentProcessIndex; i < processedFiles.length; i++) {
                // Check if we should pause or stop
                if (processingState === 'paused') {
                    currentProcessIndex = i;
                    return; // Exit the function, will resume from here
                }
                
                if (processingState === 'stopped') {
                    return; // Exit completely
                }
                
                const item = processedFiles[i];
                const file = item.file;
                showStatus(`Processing ${i + 1} of ${processedFiles.length}: ${item.collectionName} - ${item.fileName} (resizing, max side 512px)`, 'loading');
                
                // Update row to show it's being processed
                const row = document.getElementById(`row-${i}`);
                row.cells[2].textContent = 'Generating...';
                
                try {
                    const { base64, dataUrl } = await fileToBase64(file);
                    
                    // Store preview image
                    const uniqueKey = `${item.collectionName}_${item.fileName}`;
                    previewImages[uniqueKey] = dataUrl;
                    
                    // Update preview column immediately
                    const previewCell = document.getElementById(`row-${i}`).cells[4];
                    const previewImg = document.createElement('img');
                    previewImg.src = dataUrl;
                    previewImg.className = 'preview-img';
                    previewImg.title = 'Click to enlarge';
                    previewImg.onclick = function() {
                        modalImg.src = this.src;
                        modal.style.display = 'block';
                    };
                    previewCell.innerHTML = '';
                    previewCell.appendChild(previewImg);
                    
                    // Replace [collection name] with actual collection name in prepend prompt
                    const actualPrependPrompt = prependPrompt.replace(/\[collection name\]/gi, item.collectionName);
                    
                    // Combine prepend prompt with user prompts
                    const systemPrompt = `${actualPrependPrompt} ${baseSystemPrompt}`;
                    const userPrompt = baseUserPrompt ? `${actualPrependPrompt} ${baseUserPrompt}` : actualPrependPrompt;
                    
                    // Unlimited retry logic for invalid words in response
                    let seoTitle = '';
                    let retryCount = 0;
                    
                    // Keep trying until we get a valid title without invalid words
                    while (true) {
                        // Check again if we should pause or stop (in case it happens during retries)
                        if (processingState === 'paused') {
                            currentProcessIndex = i;
                            row.classList.add('paused-row');
                            return;
                        }
                        
                        if (processingState === 'stopped') {
                            return;
                        }
                        
                        if (retryCount > 0) {
                            // Update status to show retry
                            const retryStatus = document.getElementById(`row-${i}`).cells[2];
                            retryStatus.innerHTML = `Generating... <span class="retry-indicator">(Retry ${retryCount})</span>`;
                        }
                        
                        seoTitle = await generateSEOTitle(apiKey, item.fileName, base64, systemPrompt, userPrompt);
                        
                        // Check if title contains invalid words
                        if (!titleContainsInvalidWords(seoTitle)) {
                            break; // Success! Exit retry loop
                        }
                        
                        retryCount++;
                        console.log(`${item.collectionName}/${item.fileName}: Retrying... attempt ${retryCount}`);
                        
                        // Wait a bit before retrying to avoid rate limiting
                        // Increase wait time after many retries
                        const waitTime = retryCount > 10 ? 2000 : 1000;
                        await new Promise(resolve => setTimeout(resolve, waitTime));
                    }
                    
                    originalTitles[uniqueKey] = seoTitle;
                    
                    // Remove collection words from the SEO title before displaying
                    const cleanedTitle = removeCollectionWordsFromTitle(seoTitle, item.collectionName);
                    originalTitles[uniqueKey] = cleanedTitle; // Store the cleaned version
                    
                    // Update row with result
                    const displayTitle = getModifiedTitle(cleanedTitle);
                    const titleCell = document.getElementById(`row-${i}`).cells[2];
                    titleCell.textContent = displayTitle;
                    document.getElementById(`row-${i}`).cells[3].textContent = displayTitle.length;
                    checkRowHighlight(document.getElementById(`row-${i}`));
                    row.classList.remove('paused-row');
                    
                    // Add click to copy functionality
                    titleCell.title = 'Click to copy';
                    titleCell.addEventListener('click', function() {
                        copyToClipboard(this.textContent, this);
                    });
                    
                    if (retryCount > 0) {
                        console.log(`${item.collectionName}/${item.fileName}: Successfully generated after ${retryCount} retry(s)`);
                    }
                } catch (error) {
                    document.getElementById(`row-${i}`).cells[2].textContent = `Error: ${error.message}`;
                    document.getElementById(`row-${i}`).cells[3].textContent = '-';
                    document.getElementById(`row-${i}`).cells[4].textContent = 'Failed';
                    checkRowHighlight(document.getElementById(`row-${i}`));
                }
            }
            
            // Processing complete
            processingState = 'idle';
            processBtn.disabled = false;
            processBtn.textContent = 'Generate SEO Titles';
            pauseBtn.style.display = 'none';
            stopBtn.style.display = 'none';
            copyBtn.style.display = 'inline-block';
            showStatus('Processing complete!', 'success');
            currentProcessIndex = 0;
        }
        async function continueProcessing() {
            // Remove paused styling from the current row
            if (currentProcessIndex < processedFiles.length) {
                const row = document.getElementById(`row-${currentProcessIndex}`);
                if (row) {
                    row.classList.remove('paused-row');
                }
            }
            
            // Continue processing from where we left off
            await processFiles();
        }
        copyBtn.addEventListener('click', () => {
            // Create a temporary div to hold cleaned table content  
            const tempDiv = document.createElement('div');
            const tableClone = resultsTable.cloneNode(true);
            
            // Remove preview column for copying (column index 4)
            const rows = tableClone.getElementsByTagName('tr');
            for (let row of rows) {
                if (row.cells[4]) {
                    row.deleteCell(4);
                }
            }
            
            tempDiv.appendChild(tableClone);
            
            const range = document.createRange();
            range.selectNode(tempDiv.querySelector('table'));
            window.getSelection().removeAllRanges();
            window.getSelection().addRange(range);
            
            try {
                document.execCommand('copy');
                showStatus('Table copied to clipboard (without preview images)!', 'success');
            } catch (err) {
                showError('Failed to copy table');
            }
            
            window.getSelection().removeAllRanges();
            tempDiv.remove();
        });
        // OPTIMIZED IMAGE RESIZING FUNCTION - PRESERVES ASPECT RATIO
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // Create canvas for resizing
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // Calculate new dimensions preserving aspect ratio
                        const maxSize = 512;
                        let width = img.width;
                        let height = img.height;
                        
                        // Only resize if image is larger than maxSize
                        if (width > maxSize || height > maxSize) {
                            // Calculate scaling factor based on longest side
                            const scale = Math.min(maxSize / width, maxSize / height);
                            width = Math.round(width * scale);
                            height = Math.round(height * scale);
                        }
                        
                        // Set canvas dimensions
                        canvas.width = width;
                        canvas.height = height;
                        
                        // Draw resized image
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        // Convert to base64 with JPEG compression
                        canvas.toBlob((blob) => {
                            const reader = new FileReader();
                            reader.onload = () => {
                                const dataUrl = reader.result;
                                const base64 = dataUrl.split(',')[1];
                                console.log(`Image ${file.name} resized from ${img.width}x${img.height} to ${width}x${height}`);
                                resolve({ base64, dataUrl });
                            };
                            reader.onerror = reject;
                            reader.readAsDataURL(blob);
                        }, 'image/jpeg', 0.85); // 85% quality for good balance
                    };
                    img.onerror = () => reject(new Error('Failed to load image'));
                    img.src = e.target.result;
                };
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsDataURL(file);
            });
        }
        async function generateSEOTitle(apiKey, fileName, base64Image, systemPrompt, userPrompt) {
            // Clean and validate the API key
            const cleanApiKey = apiKey.trim().replace(/[^\x00-\x7F]/g, '');
            
            const messages = [
                {
                    role: "system",
                    content: systemPrompt
                },
                {
                    role: "user",
                    content: [
                        {
                            type: "text",
                            text: `Filename: ${fileName}. ${userPrompt}`
                        },
                        {
                            type: "image_url",
                            image_url: {
                                url: `data:image/jpeg;base64,${base64Image}`,
                                detail: "low"  // Explicitly use low detail for cost savings
                            }
                        }
                    ]
                }
            ];
            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + cleanApiKey
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o',
                        messages: messages,
                        max_tokens: 100,
                        temperature: 0.7
                    })
                });
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error?.message || 'API request failed');
                }
                const data = await response.json();
                return data.choices[0].message.content.trim();
            } catch (error) {
                console.error('API Request Error:', error);
                if (error.message.includes('ISO-8859-1')) {
                    throw new Error('Invalid API key format. Please check for special characters or spaces.');
                }
                throw error;
            }
        }
        function copyToClipboard(text, element) {
            // Don't copy if it's already showing "Copied!"
            if (element.textContent === 'Copied!') return;
            
            // Create temporary textarea
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'absolute';
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            
            // Select and copy
            textarea.select();
            try {
                document.execCommand('copy');
                
                // Visual feedback
                const originalText = element.textContent;
                element.textContent = 'Copied!';
                element.classList.add('copied');
                
                setTimeout(() => {
                    element.textContent = originalText;
                    element.classList.remove('copied');
                }, 1000);
            } catch (err) {
                showError('Failed to copy text');
            }
            
            document.body.removeChild(textarea);
        }
        function checkRowHighlight(row) {
            const seoTitle = row.cells[2].textContent.toLowerCase();
            const charCount = parseInt(row.cells[3].textContent);
            
            // Check for invalid words or character count
            if (titleContainsInvalidWords(seoTitle) || charCount > 100) {
                row.classList.add('error-row');
            } else {
                row.classList.remove('error-row');
            }
        }
        function getModifiedTitle(originalTitle) {
            const prefix = prefixModifier.value.trim();
            const suffix = suffixModifier.value.trim();
            let result = originalTitle;
            
            if (prefix) {
                result = prefix + result;
            }
            
            if (suffix) {
                result = result + suffix;
            }
            
            return result;
        }
        function updateAllTitles() {
            const rows = resultsBody.getElementsByTagName('tr');
            for (let row of rows) {
                const collectionName = row.cells[0].textContent;
                const fileName = row.cells[1].textContent;
                const uniqueKey = `${collectionName}_${fileName}`;
                const originalTitle = originalTitles[uniqueKey];
                if (originalTitle && !row.cells[2].textContent.startsWith('Error:')) {
                    const modifiedTitle = getModifiedTitle(originalTitle);
                    row.cells[2].textContent = modifiedTitle;
                    row.cells[3].textContent = modifiedTitle.length;
                    checkRowHighlight(row);
                    
                    // Re-add click handler and maintain clickability
                    row.cells[2].title = 'Click to copy';
                    if (!row.cells[2].onclick) {
                        row.cells[2].onclick = function() {
                            copyToClipboard(this.textContent, this);
                        };
                    }
                }
            }
        }
        function showStatus(message, type) {
            status.className = type === 'error' ? 'status error' : type === 'success' ? 'status success' : type === 'warning' ? 'status warning' : type === 'paused' ? 'status paused' : 'status';
            status.textContent = message;
            
            if (type !== 'loading' && type !== 'paused') {
                setTimeout(() => {
                    status.textContent = '';
                    status.className = '';
                }, 3000);
            }
        }
        function showError(message) {
            showStatus(message, 'error');
        }
    </script>
</body>
</html>